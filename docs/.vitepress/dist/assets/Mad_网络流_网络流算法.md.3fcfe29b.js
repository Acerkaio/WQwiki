import{_ as a,o as l,c as i,Q as o}from"./chunks/framework.e7363dcb.js";const q=JSON.parse('{"title":"网络流算法","description":"","frontmatter":{},"headers":[],"relativePath":"Mad/网络流/网络流算法.md","filePath":"Mad/网络流/网络流算法.md","lastUpdated":1740448168000}'),t={name:"Mad/网络流/网络流算法.md"},e=o('<h1 id="网络流算法" tabindex="-1">网络流算法 <a class="header-anchor" href="#网络流算法" aria-label="Permalink to &quot;网络流算法&quot;">​</a></h1><h2 id="最大流问题" tabindex="-1">最大流问题 <a class="header-anchor" href="#最大流问题" aria-label="Permalink to &quot;最大流问题&quot;">​</a></h2><h3 id="ek" tabindex="-1">EK <a class="header-anchor" href="#ek" aria-label="Permalink to &quot;EK&quot;">​</a></h3><ol><li>首先考虑将最大流分解成一条一条的路径（增广路）。</li><li>显然，最大流的必要条件是没有增广路。</li><li>但在有多条增广路时，增广哪一条路？ <ul><li>直接随便一条肯定是错的，这时，需要引入算法的核心：反悔边。</li></ul></li><li>那么，每次增广以后，将路径上的边容量减去流量，其反边加上流量即可。</li><li>复杂度不会证。</li></ol><h3 id="dinic" tabindex="-1">dinic <a class="header-anchor" href="#dinic" aria-label="Permalink to &quot;dinic&quot;">​</a></h3><ol><li>将EK扩展到多路增广，具体利用了分层图实现。</li></ol><h3 id="复杂度" tabindex="-1">复杂度 <a class="header-anchor" href="#复杂度" aria-label="Permalink to &quot;复杂度&quot;">​</a></h3><ol><li><strong>dinic增广轮数</strong>： <ul><li><strong>一般图</strong>：$n$</li><li><strong>值域相关上界</strong>：$\\sqrt{\\sum_{v\\in V}\\min(\\text{入度容量和},\\text{出度容量和})}$</li></ul></li><li><strong>dinic单次增广</strong>： <ul><li><strong>一般图</strong>：$n\\cdot m$</li><li><strong>值域相关上界</strong>：在所有边容量都比较小的时候，好像近似$m$</li></ul></li></ol><h2 id="费用流问题" tabindex="-1">费用流问题 <a class="header-anchor" href="#费用流问题" aria-label="Permalink to &quot;费用流问题&quot;">​</a></h2><h3 id="ssp" tabindex="-1">SSP <a class="header-anchor" href="#ssp" aria-label="Permalink to &quot;SSP&quot;">​</a></h3><ol><li><strong>条件</strong>：没有费用为负的圈。</li><li><strong>流程</strong>： <ul><li>将反悔边的费用设成负数。</li><li>每次寻找费用最少的路径进行增广即可。</li></ul></li><li><strong>具体实现</strong>： <ul><li>利用spfa直接跑最短路。</li><li>复杂度：$n\\cdot m\\cdot f$</li></ul></li></ol><h3 id="primal-dual" tabindex="-1">Primal - Dual <a class="header-anchor" href="#primal-dual" aria-label="Permalink to &quot;Primal - Dual&quot;">​</a></h3><ol><li>原理和SSP相同，核心在于求最短路部分，用 势能 + dij。</li><li>初始势能可以跑spfa赋，然后考虑每次增广完以后如何改变势能。</li><li>势能直接加上dis数组即可，证明略。</li><li>复杂度：$f\\cdot(n + m)\\cdot\\log m$</li></ol><h3 id="有负环的费用流" tabindex="-1">有负环的费用流 <a class="header-anchor" href="#有负环的费用流" aria-label="Permalink to &quot;有负环的费用流&quot;">​</a></h3><ol><li>将所有的负权边强制满流，然后留下反悔边。</li><li>这样就让部分点流量不守恒了，所以套上下界的板子。</li></ol><h2 id="上下界网络流" tabindex="-1">上下界网络流 <a class="header-anchor" href="#上下界网络流" aria-label="Permalink to &quot;上下界网络流&quot;">​</a></h2><h3 id="整体思路" tabindex="-1">整体思路 <a class="header-anchor" href="#整体思路" aria-label="Permalink to &quot;整体思路&quot;">​</a></h3><ol><li>考虑将下界去掉，即 强制满流到下界，然后改权值为上界 - 下界。</li><li>但这样每个点的流量都不一定守恒。</li><li>可以先给出一种流使得流量守恒，然后再调整到要求的流。</li></ol><h3 id="可行流部分" tabindex="-1">可行流部分 <a class="header-anchor" href="#可行流部分" aria-label="Permalink to &quot;可行流部分&quot;">​</a></h3><ol><li>新建超级源汇，正权点连源点，负权点连汇点，跑最大流。</li><li>注意，对于原图有源汇的情况，需要汇点向源点连$\\infty$边。</li><li>注意判断如果流不满就是无解。</li></ol><h3 id="调整部分" tabindex="-1">调整部分 <a class="header-anchor" href="#调整部分" aria-label="Permalink to &quot;调整部分&quot;">​</a></h3><ol><li>将可行流部分建的边都拆掉，然后该怎么样就怎么样。</li></ol>',22),r=[e];function n(s,d,h,c,u,m){return l(),i("div",null,r)}const b=a(t,[["render",n]]);export{q as __pageData,b as default};
