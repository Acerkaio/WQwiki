import{_ as a,o as e,c as l,Q as i}from"./chunks/framework.e7363dcb.js";const b=JSON.parse('{"title":"模拟费用流","description":"","frontmatter":{},"headers":[],"relativePath":"Mad/模拟费用流.md","filePath":"Mad/模拟费用流.md","lastUpdated":1740448168000}'),o={name:"Mad/模拟费用流.md"},t=i('<h1 id="模拟费用流" tabindex="-1">模拟费用流 <a class="header-anchor" href="#模拟费用流" aria-label="Permalink to &quot;模拟费用流&quot;">​</a></h1><h2 id="核心思考方法" tabindex="-1">核心思考方法 <a class="header-anchor" href="#核心思考方法" aria-label="Permalink to &quot;核心思考方法&quot;">​</a></h2><h3 id="增量-消圈法" tabindex="-1">增量 - 消圈法 <a class="header-anchor" href="#增量-消圈法" aria-label="Permalink to &quot;增量 - 消圈法&quot;">​</a></h3><h4 id="适用范围" tabindex="-1">适用范围 <a class="header-anchor" href="#适用范围" aria-label="Permalink to &quot;适用范围&quot;">​</a></h4><ul><li>最小费用可行流</li><li>最小费用最大流：将连向汇点的边费用减 <code>inf</code>，转化为可行流</li></ul><h4 id="处理" tabindex="-1">处理 <a class="header-anchor" href="#处理" aria-label="Permalink to &quot;处理&quot;">​</a></h4><p>每次考虑加入新的点和边，新产生的：</p><ol><li>负圈</li><li>源汇负路</li></ol><h2 id="模拟ek" tabindex="-1">模拟EK <a class="header-anchor" href="#模拟ek" aria-label="Permalink to &quot;模拟EK&quot;">​</a></h2><h3 id="适用范围-1" tabindex="-1">适用范围 <a class="header-anchor" href="#适用范围-1" aria-label="Permalink to &quot;适用范围&quot;">​</a></h3><p>很广</p><h3 id="处理-1" tabindex="-1">处理 <a class="header-anchor" href="#处理-1" aria-label="Permalink to &quot;处理&quot;">​</a></h3><p>考虑每次新找一条最短增广路</p><h2 id="常用结论" tabindex="-1">常用结论 <a class="header-anchor" href="#常用结论" aria-label="Permalink to &quot;常用结论&quot;">​</a></h2><p>增广路（负圈）不会重复经过同一节点</p><h2 id="例题" tabindex="-1">例题 <a class="header-anchor" href="#例题" aria-label="Permalink to &quot;例题&quot;">​</a></h2><h3 id="老鼠钻洞plus版-「icpc-world-finals-2018」征服世界" tabindex="-1">老鼠钻洞plus版：「ICPC World Finals 2018」征服世界 <a class="header-anchor" href="#老鼠钻洞plus版-「icpc-world-finals-2018」征服世界" aria-label="Permalink to &quot;老鼠钻洞plus版：「ICPC World Finals 2018」征服世界&quot;">​</a></h3><h4 id="solution" tabindex="-1">solution <a class="header-anchor" href="#solution" aria-label="Permalink to &quot;solution&quot;">​</a></h4><ol><li>首先建出费用流模型：类似上下界网络流，将两个权值相减跑最小费用最大流。</li><li>考虑模拟费用流，先将最大流转可行流，增量法处理。</li><li>考虑每次加入子树的根节点，每次只要看子树中的入流和出流（之前子树已经流尽了）。</li><li>因为路径可以拆价值，所以直接匹配入和出就可以，结合可并堆实现即可。</li></ol>',19),r=[t];function h(n,d,s,c,u,_){return e(),l("div",null,r)}const q=a(o,[["render",h]]);export{b as __pageData,q as default};
