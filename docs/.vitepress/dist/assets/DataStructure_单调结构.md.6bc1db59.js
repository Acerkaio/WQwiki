import{_ as a,o as e,c as t,Q as r}from"./chunks/framework.e7363dcb.js";const p=JSON.parse('{"title":"单调结构","description":"","frontmatter":{},"headers":[],"relativePath":"DataStructure/单调结构.md","filePath":"DataStructure/单调结构.md","lastUpdated":1740448168000}'),l={name:"DataStructure/单调结构.md"},i=r('<h1 id="单调结构" tabindex="-1">单调结构 <a class="header-anchor" href="#单调结构" aria-label="Permalink to &quot;单调结构&quot;">​</a></h1><h2 id="单调栈" tabindex="-1">单调栈 <a class="header-anchor" href="#单调栈" aria-label="Permalink to &quot;单调栈&quot;">​</a></h2><h3 id="功能" tabindex="-1">功能 <a class="header-anchor" href="#功能" aria-label="Permalink to &quot;功能&quot;">​</a></h3><p>维护后缀最小值序列。</p><h3 id="支持的修改" tabindex="-1">支持的修改 <a class="header-anchor" href="#支持的修改" aria-label="Permalink to &quot;支持的修改&quot;">​</a></h3><p>每次可以向数组末尾加一个数。</p><h3 id="支持的查询" tabindex="-1">支持的查询 <a class="header-anchor" href="#支持的查询" aria-label="Permalink to &quot;支持的查询&quot;">​</a></h3><h4 id="线性复杂度查询" tabindex="-1">线性复杂度查询 <a class="header-anchor" href="#线性复杂度查询" aria-label="Permalink to &quot;线性复杂度查询&quot;">​</a></h4><ul><li>每次询问的值单调不降，且始终不大于下一个要插入的数。</li><li>常见应用：查询某个插入数前面第一个大于当前数的位置。</li></ul><h4 id="对数复杂度查询" tabindex="-1">对数复杂度查询 <a class="header-anchor" href="#对数复杂度查询" aria-label="Permalink to &quot;对数复杂度查询&quot;">​</a></h4><p>对询问值没有要求，结合二分实现即可。</p><h3 id="例题" tabindex="-1">例题 <a class="header-anchor" href="#例题" aria-label="Permalink to &quot;例题&quot;">​</a></h3><p><strong>CF1988E</strong>：经典问题</p><ul><li>直接二分和 st 表的做法略去，考虑怎么线性实现求 $l, r, l_2, r_2$。</li><li>$l, r$ 分别是求前后缀第一个小于当前数的位置，经典的单调栈。</li><li>再考虑 $l_2$（$r_2$ 同理），即 $l$ 左边的第一个小于当前数的位置，发现查询可以满足限制（$a[l]$ 一定小于 $a[i]$）。</li><li>所以我们要首先让 $l$ 有单调性（便于加数），然后让查询的 $a$ 值有单调性。这需要排序。为了线性，用二维桶排即可。</li><li>此做法可以扩展到求 $l_k$ 和 $r_k$ 的情况。</li></ul><h2 id="单调队列" tabindex="-1">单调队列 <a class="header-anchor" href="#单调队列" aria-label="Permalink to &quot;单调队列&quot;">​</a></h2><h3 id="功能-1" tabindex="-1">功能 <a class="header-anchor" href="#功能-1" aria-label="Permalink to &quot;功能&quot;">​</a></h3><p>维护一个线性单调变化的范围内的最值。 其实理论上，我们维护的还是后缀最小值序列，但是在很多情况下都只查询最值。</p>',17),o=[i];function h(n,d,s,c,_,u){return e(),t("div",null,o)}const b=a(l,[["render",h]]);export{p as __pageData,b as default};
