import{_ as a,o as l,c as i,Q as e}from"./chunks/framework.e7363dcb.js";const q=JSON.parse('{"title":"一些DP相关","description":"","frontmatter":{},"headers":[],"relativePath":"Mad/DP/一些DP相关.md","filePath":"Mad/DP/一些DP相关.md","lastUpdated":1738666900000}'),r={name:"Mad/DP/一些DP相关.md"},t=e('<h1 id="一些dp相关" tabindex="-1">一些DP相关 <a class="header-anchor" href="#一些dp相关" aria-label="Permalink to &quot;一些DP相关&quot;">​</a></h1><h2 id="换根dp" tabindex="-1">换根DP <a class="header-anchor" href="#换根dp" aria-label="Permalink to &quot;换根DP&quot;">​</a></h2><ul><li><strong>计数DP</strong>：直接容斥法</li><li><strong>最值DP</strong>：维护最大次大值法，前后缀合并法</li></ul><h2 id="树上连通块dp" tabindex="-1">树上连通块DP <a class="header-anchor" href="#树上连通块dp" aria-label="Permalink to &quot;树上连通块DP&quot;">​</a></h2><ul><li><strong>法一</strong>：直接DP，在过程中钦定当前点为最浅点</li><li><strong>法二</strong>：基于DP插入复杂度小于合并复杂度，类似shopping的做法</li><li><strong>例题</strong>：shopping</li></ul><h2 id="划分型dp" tabindex="-1">划分型DP <a class="header-anchor" href="#划分型dp" aria-label="Permalink to &quot;划分型DP&quot;">​</a></h2><ul><li><strong>处理问题</strong>：将一个序列分成两个子序列（染两种颜色），然后要满足某些限制</li><li><strong>DP式通常形如</strong>： <ul><li>$dp[i][j] \\leftarrow dp[i - 1][j]$</li><li>$dp[i][i - 1] \\leftarrow dp[i - 1][j]$</li></ul></li><li><strong>注意</strong>：应熟知此类DP是很好优化的</li></ul><h3 id="例题" tabindex="-1">例题 <a class="header-anchor" href="#例题" aria-label="Permalink to &quot;例题&quot;">​</a></h3><ul><li>CF1849F</li><li>P11233</li><li>CF1647F</li></ul><h2 id="min-f-l-i-f-i-r-的处理" tabindex="-1">$\\min(f(l,i),f(i,r))$ 的处理 <a class="header-anchor" href="#min-f-l-i-f-i-r-的处理" aria-label="Permalink to &quot;$\\min(f(l,i),f(i,r))$ 的处理&quot;">​</a></h2><ul><li><strong>首先</strong>：$f$ 应该有不严格单调性</li><li><strong>然后常见的，有两种处理办法</strong>： <ul><li><strong>双指针</strong>：钦定左边大于右边，然后答案必然只从两分界点中取</li><li><strong>二分</strong>： <ul><li>根据左边和右边的大小做二分</li><li>当左右相等时必然最优（剪枝）</li><li>可以用不常用写法</li></ul></li></ul></li></ul><h3 id="例题-1" tabindex="-1">例题 <a class="header-anchor" href="#例题-1" aria-label="Permalink to &quot;例题&quot;">​</a></h3><p>太多了，懒得找</p><h2 id="处理dp的二维价值" tabindex="-1">处理DP的二维价值 <a class="header-anchor" href="#处理dp的二维价值" aria-label="Permalink to &quot;处理DP的二维价值&quot;">​</a></h2><h3 id="基本处理办法" tabindex="-1">基本处理办法 <a class="header-anchor" href="#基本处理办法" aria-label="Permalink to &quot;基本处理办法&quot;">​</a></h3><p>把一维价值也设入状态中，转换成背包问题</p><h3 id="常见剪枝" tabindex="-1">常见剪枝 <a class="header-anchor" href="#常见剪枝" aria-label="Permalink to &quot;常见剪枝&quot;">​</a></h3><p>只存下有值的状态，在转移完做一下单调性剪枝</p><ul><li><strong>相关研究</strong>： <ul><li>其不能直接降低复杂度（基本量级不变）</li><li>但是，转移次数越多，转移越复杂，可以除以的常数越大</li><li>其算法瓶颈通常在枚举状态进行转移，以及后续的剪枝（考虑算法时间时主要考虑这一点）</li></ul></li></ul><h3 id="特别的优化办法" tabindex="-1">特别的优化办法 <a class="header-anchor" href="#特别的优化办法" aria-label="Permalink to &quot;特别的优化办法&quot;">​</a></h3><ul><li>分析DP性质，去掉一维价值</li><li>直接贪心，考虑怎么选</li><li>换做法</li></ul><h3 id="例题-2" tabindex="-1">例题 <a class="header-anchor" href="#例题-2" aria-label="Permalink to &quot;例题&quot;">​</a></h3><ul><li>AGC035D</li></ul><h3 id="例题-3" tabindex="-1">例题 <a class="header-anchor" href="#例题-3" aria-label="Permalink to &quot;例题&quot;">​</a></h3><p><strong>P9051</strong>：</p><ul><li>首先二分转判定</li><li>朴素的DP有两维价值，但注意到DP的第一维价值后面都不会用到</li><li>那么，我们可以直接在求出第一维价值时就判定是否大于 $mid$</li><li>这样只用保留一维价值</li></ul><h2 id="值域定义域互换" tabindex="-1">值域定义域互换 <a class="header-anchor" href="#值域定义域互换" aria-label="Permalink to &quot;值域定义域互换&quot;">​</a></h2><h3 id="适用范围" tabindex="-1">适用范围 <a class="header-anchor" href="#适用范围" aria-label="Permalink to &quot;适用范围&quot;">​</a></h3><p>最优化DP状态的优化，DP值有单调性</p><h3 id="注意点" tabindex="-1">注意点 <a class="header-anchor" href="#注意点" aria-label="Permalink to &quot;注意点&quot;">​</a></h3><ul><li>在互换后，一般状态都不能设“恰好”</li><li>保证得到的DP值是当前答案等于或劣于状态中的答案</li></ul><h3 id="例题-4" tabindex="-1">例题 <a class="header-anchor" href="#例题-4" aria-label="Permalink to &quot;例题&quot;">​</a></h3><h4 id="lis" tabindex="-1">LIS <a class="header-anchor" href="#lis" aria-label="Permalink to &quot;LIS&quot;">​</a></h4><ul><li>可以直接设 $dp_i$ 表示LIS长度为 $i$ 的最小的结尾值，$dp$ 初始为 $inf$</li><li>然后每次扫进新数 $x$，就在 $dp$ 数组里找到 $\\geq x$ 的第一个位置，$chkmin(dp,x)$ 即可</li><li>可以发现，某种程度上这避免了离散化</li><li><strong>practice</strong>: [ABC360G] Suitable Edit for LIS</li></ul><h4 id="abc364e-maximum-glutton" tabindex="-1">ABC364E Maximum Glutton <a class="header-anchor" href="#abc364e-maximum-glutton" aria-label="Permalink to &quot;ABC364E  Maximum Glutton&quot;">​</a></h4><ul><li>观察到 $N$ 很小，但是对于搜索剪枝来说又不够小（一般应该是30 - 40, 40 - 50可能是折半）</li><li>直接做，显然是二维的背包，但是状态太大了，显得很冗余</li><li>因为此题是经典DP题（显然不能贪心），所以仍考虑优化DP</li><li>观察到值域其实只有 $N$ 的，而且有单调性，所以值域定义域互换即可</li></ul><h2 id="_1d-1d" tabindex="-1">1D/1D <a class="header-anchor" href="#_1d-1d" aria-label="Permalink to &quot;1D/1D&quot;">​</a></h2><p>自己规定了在线转移和非在线转移两个概念</p><h3 id="简化dp转移" tabindex="-1">简化DP转移 <a class="header-anchor" href="#简化dp转移" aria-label="Permalink to &quot;简化DP转移&quot;">​</a></h3><p>给DP分层，或给DP的转移分类，从而转化成1D/1D问题</p><h2 id="决策单调性" tabindex="-1">决策单调性 <a class="header-anchor" href="#决策单调性" aria-label="Permalink to &quot;决策单调性&quot;">​</a></h2><h3 id="适用场景" tabindex="-1">适用场景 <a class="header-anchor" href="#适用场景" aria-label="Permalink to &quot;适用场景&quot;">​</a></h3><p>没有其他思路，只有一个DP，而且没法用其他优化</p><h3 id="验证方法" tabindex="-1">验证方法 <a class="header-anchor" href="#验证方法" aria-label="Permalink to &quot;验证方法&quot;">​</a></h3><p>暴力跑随机数据看决策点是否单调</p><h3 id="实现方法" tabindex="-1">实现方法 <a class="header-anchor" href="#实现方法" aria-label="Permalink to &quot;实现方法&quot;">​</a></h3><ul><li><strong>决策栈 + 二分</strong>：处理在线转移</li><li><strong>分治</strong>：处理非在线转移</li></ul><h3 id="ps" tabindex="-1">PS <a class="header-anchor" href="#ps" aria-label="Permalink to &quot;PS&quot;">​</a></h3><ul><li>有的斜率优化可能表现出了决策单调性</li><li>有的决策单调性是因为有凸性，此时也可以用下述的优化</li></ul><h2 id="凸性相关" tabindex="-1">凸性相关 <a class="header-anchor" href="#凸性相关" aria-label="Permalink to &quot;凸性相关&quot;">​</a></h2><h3 id="前置知识" tabindex="-1">前置知识 <a class="header-anchor" href="#前置知识" aria-label="Permalink to &quot;前置知识&quot;">​</a></h3><h4 id="如何发现dp的凸性" tabindex="-1">如何发现DP的凸性 <a class="header-anchor" href="#如何发现dp的凸性" aria-label="Permalink to &quot;如何发现DP的凸性&quot;">​</a></h4><ul><li>满足四边形不等式的序列划分问题的答案（一定是）</li><li>转移每次加上一个凸函数（较有可能是）</li><li>直观理解很凸（较可能是）</li><li>费用流建模（一定是）</li><li>其他验证方法：暴力跑随机数据验证</li></ul><h3 id="常见算法" tabindex="-1">常见算法 <a class="header-anchor" href="#常见算法" aria-label="Permalink to &quot;常见算法&quot;">​</a></h3><h4 id="闵可夫斯基和" tabindex="-1">闵可夫斯基和 <a class="header-anchor" href="#闵可夫斯基和" aria-label="Permalink to &quot;闵可夫斯基和&quot;">​</a></h4><ul><li>转移是 $(\\max, +)$ 卷积</li><li>具体而言，要求DP是非在线转移</li><li>经典的，其可以优化背包合并</li></ul><h4 id="wqs二分" tabindex="-1">wqs二分 <a class="header-anchor" href="#wqs二分" aria-label="Permalink to &quot;wqs二分&quot;">​</a></h4><ul><li>答案求“恰 $k$ 个”</li><li>可以直接去掉表示选多少个的那一维（背包DP）</li></ul><h4 id="slope-trick" tabindex="-1">slope trick <a class="header-anchor" href="#slope-trick" aria-label="Permalink to &quot;slope trick&quot;">​</a></h4><ul><li><strong>核心</strong>：利用凸性动态维护DP数组</li><li><strong>处理过程</strong>： <ul><li>将DP数组转换成单调的，方便维护（差分数组单调且均非负）</li><li>使用DS维护对DP数组的操作，通常维护的是差分数组和其首项（或某一项）</li></ul></li></ul><h3 id="一些要分析dp数组形态的题" tabindex="-1">一些要分析DP数组形态的题 <a class="header-anchor" href="#一些要分析dp数组形态的题" aria-label="Permalink to &quot;一些要分析DP数组形态的题&quot;">​</a></h3><h4 id="sonya-and-problem-wihtout-a-legend" tabindex="-1">Sonya and Problem Wihtout a Legend <a class="header-anchor" href="#sonya-and-problem-wihtout-a-legend" aria-label="Permalink to &quot;Sonya and Problem Wihtout a Legend&quot;">​</a></h4><p><strong>solution1</strong>:</p><ul><li>有暴力DP，没什么贪心的思路，可以继续优化DP</li><li>DP形如凸函数加起来，猜一个凸</li><li>确实，所以维护一下差分，注意修改时保证始终 $\\geq 0$</li><li>最后要维护一个实际DP值才能用差分推出答案，随便取一个即可</li></ul><p><strong>solution2</strong>:</p><ul><li>序列递增，直接差分，发现就是要让差分数组全变成 $&gt; 0$</li><li>操作每次会将差分的一个数 $++$，下一个数 $--$，或是相反</li><li>很流，可以费用流，竟然过了</li></ul><h4 id="p9051" tabindex="-1">P9051 <a class="header-anchor" href="#p9051" aria-label="Permalink to &quot;P9051&quot;">​</a></h4><ul><li><strong>经典凸性转移形式</strong>：网格图两种走法求最短路</li><li><strong>处理</strong>： <ul><li>考虑直接维护差分数组及首项</li><li>首项是好处理的</li><li>差分数组每次直接插入一个数就可以了</li><li>剩下的一些细节就特殊处理</li></ul></li></ul>',68),o=[t];function n(h,d,s,u,c,P){return l(),i("div",null,o)}const p=a(r,[["render",n]]);export{q as __pageData,p as default};
