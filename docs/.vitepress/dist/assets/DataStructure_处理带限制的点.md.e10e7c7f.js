import{_ as s,o as n,c as a,Q as l}from"./chunks/framework.e7363dcb.js";const d=JSON.parse('{"title":"处理带限制的点","description":"","frontmatter":{},"headers":[],"relativePath":"DataStructure/处理带限制的点.md","filePath":"DataStructure/处理带限制的点.md","lastUpdated":1738591681000}'),e={name:"DataStructure/处理带限制的点.md"},p=l(`<h1 id="处理带限制的点" tabindex="-1">处理带限制的点 <a class="header-anchor" href="#处理带限制的点" aria-label="Permalink to &quot;处理带限制的点&quot;">​</a></h1><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">问题描述：</span></span>
<span class="line"><span style="color:#e1e4e8;">	很多DS问题最终会转化成一个很基本的问题：点的问题</span></span>
<span class="line"><span style="color:#e1e4e8;">	常见的是：统计点数（能差分）/最优化点权（不能差分）</span></span>
<span class="line"><span style="color:#e1e4e8;">	同时，问题会对合法的点进行抽象定义</span></span>
<span class="line"><span style="color:#e1e4e8;">	那么，问题的难点就在于将抽象的合法限制以优的复杂度实现</span></span>
<span class="line"><span style="color:#e1e4e8;">常识：</span></span>
<span class="line"><span style="color:#e1e4e8;">	静态的k维问题的复杂度一般为log^(k-1)</span></span>
<span class="line"><span style="color:#e1e4e8;">	动态的k维问题的复杂度一般为log^k</span></span>
<span class="line"><span style="color:#e1e4e8;">整体思路：</span></span>
<span class="line"><span style="color:#e1e4e8;">	核心：用尽可能少的log刻画出限制</span></span>
<span class="line"><span style="color:#e1e4e8;">	有时，你容易提出一个log特别多的限制办法，这时重点就是想办法减少限制</span></span>
<span class="line"><span style="color:#e1e4e8;">对限制的具体处理思路：</span></span>
<span class="line"><span style="color:#e1e4e8;">	处理修改：</span></span>
<span class="line"><span style="color:#e1e4e8;">		将时间维看成一维限制处理：</span></span>
<span class="line"><span style="color:#e1e4e8;">			查询看成是对时间维的前缀修改点查询</span></span>
<span class="line"><span style="color:#e1e4e8;">		直接在线修改处理</span></span>
<span class="line"><span style="color:#e1e4e8;">	处理偏序（单限制不等式）：</span></span>
<span class="line"><span style="color:#e1e4e8;">		离线：扫描线（即CDQ的一维形态），CDQ分治</span></span>
<span class="line"><span style="color:#e1e4e8;">			离线带修可以将时间维看作一维限制</span></span>
<span class="line"><span style="color:#e1e4e8;">		在线不带修：序列上可持久化结构（例如主席树）</span></span>
<span class="line"><span style="color:#e1e4e8;">		在线带修：树状数组</span></span>
<span class="line"><span style="color:#e1e4e8;">	处理一般不等式：</span></span>
<span class="line"><span style="color:#e1e4e8;">		尝试套用偏序做法：</span></span>
<span class="line"><span style="color:#e1e4e8;">			可以差分：差分后套偏序做法</span></span>
<span class="line"><span style="color:#e1e4e8;">			扫描线可以结合带修DS使用</span></span>
<span class="line"><span style="color:#e1e4e8;">			一般的：分治套偏序做法</span></span>
<span class="line"><span style="color:#e1e4e8;">		树套树：</span></span>
<span class="line"><span style="color:#e1e4e8;">			一维形态：线段树</span></span>
<span class="line"><span style="color:#e1e4e8;">			BIT套SGT：一维偏序，一维双向</span></span>
<span class="line"><span style="color:#e1e4e8;">			SGT套SGT（二维线段树）：两维双向</span></span>
<span class="line"><span style="color:#e1e4e8;">		K-D tree</span></span>
<span class="line"><span style="color:#e1e4e8;">	注意：</span></span>
<span class="line"><span style="color:#e1e4e8;">		优先考虑离线做法，在线做法时空比较劣</span></span>
<span class="line"><span style="color:#e1e4e8;">		并不一定要用时间维分析，因为时间维将修改操作一般化了，失去了特殊性</span></span>
<span class="line"><span style="color:#e1e4e8;">处理限制的思考技巧：</span></span>
<span class="line"><span style="color:#e1e4e8;">	一般化表示比较复杂，可以简单分类讨论：</span></span>
<span class="line"><span style="color:#e1e4e8;">		情况变多了，但单个情况的条件变少了，去除了冗余条件</span></span>
<span class="line"><span style="color:#e1e4e8;">	灵活转化/分裂/合并偏序限制和一般限制：</span></span>
<span class="line"><span style="color:#e1e4e8;">		一般限制可以拆分成上下界的偏序限制</span></span>
<span class="line"><span style="color:#e1e4e8;">			特别的，可差分的问题可以直接去掉一般限制</span></span>
<span class="line"><span style="color:#e1e4e8;">		有时，多个偏序限制可以合并成一个一般限制</span></span>
<span class="line"><span style="color:#e1e4e8;">	询问和点贡献方式互换：</span></span>
<span class="line"><span style="color:#e1e4e8;">		有时询问贡献点更好处理，就要交换</span></span>
<span class="line"><span style="color:#e1e4e8;">	其他的思考技巧就和分析性质相似了</span></span>
<span class="line"><span style="color:#e1e4e8;">典例：</span></span>
<span class="line"><span style="color:#e1e4e8;">	区间mex：</span></span>
<span class="line"><span style="color:#e1e4e8;">		显然二分，问题就变成：&lt;=lim的所有数是否都在[l,r]中出现</span></span>
<span class="line"><span style="color:#e1e4e8;">		出现可以刻画成：对于x的所有出现位置pos,存在l&lt;=pos&lt;=r</span></span>
<span class="line"><span style="color:#e1e4e8;">		拆偏序处理，那么pos&lt;=r直接扫掉，条件就转化成max(pos)&gt;=l</span></span>
<span class="line"><span style="color:#e1e4e8;">	给定若干区间[li,ri]以及对应权值ci，多次询问和[l,r]的交&gt;=k的区间的最小权值：</span></span>
<span class="line"><span style="color:#e1e4e8;">		直接分析的话可以列出一堆条件，非常麻烦，考虑减少条件数</span></span>
<span class="line"><span style="color:#e1e4e8;">		有交这个一般条件刻画复杂，考虑分类讨论：</span></span>
<span class="line"><span style="color:#e1e4e8;">			完全包含，完全被包含，包含左端点，包含右端点</span></span>
<span class="line"><span style="color:#e1e4e8;">		完全包含可以被最后两个替代，只剩三种情况</span></span>
<span class="line"><span style="color:#e1e4e8;">		最后两个都是好做的，即二维偏序</span></span>
<span class="line"><span style="color:#e1e4e8;">		完全被包含需要对长度和左右端点做限制，即：</span></span>
<span class="line"><span style="color:#e1e4e8;">			l&lt;=li,ri&lt;=r,ri-lr+1&gt;=k</span></span>
<span class="line"><span style="color:#e1e4e8;">		这并不足以通过，考虑再次优化条件</span></span>
<span class="line"><span style="color:#e1e4e8;">		发现前两个偏序可以合并成对ri的双向限制，那么扫偏序再线段树处理双向限制即可</span></span>
<span class="line"><span style="color:#e1e4e8;">	区间查询前驱：</span></span>
<span class="line"><span style="color:#e1e4e8;">		问题可以刻画成：</span></span>
<span class="line"><span style="color:#e1e4e8;">			每个点(pos,val)</span></span>
<span class="line"><span style="color:#e1e4e8;">			lim：l&lt;=pos&lt;=r,val&lt;=x</span></span>
<span class="line"><span style="color:#e1e4e8;">			aim：maximum(val)</span></span>
<span class="line"><span style="color:#e1e4e8;">		观察到限制形态，直接有一个离线静态做法：</span></span>
<span class="line"><span style="color:#e1e4e8;">			扫描掉偏序，剩下的用SGT</span></span>
<span class="line"><span style="color:#e1e4e8;">		</span></span>
<span class="line"><span style="color:#e1e4e8;">		假如离线动态呢？	将时间维也刻画出来：</span></span>
<span class="line"><span style="color:#e1e4e8;">			每个点(tl,tr,pos,val)，询问(t,l,r,x)</span></span>
<span class="line"><span style="color:#e1e4e8;">			lim：tl&lt;=t&lt;=tr,l&lt;=pos&lt;=r,val&lt;=x</span></span>
<span class="line"><span style="color:#e1e4e8;">			aim:maximum(val)</span></span>
<span class="line"><span style="color:#e1e4e8;">		一个办法是把一般不等式拆掉，应该是log^3</span></span>
<span class="line"><span style="color:#e1e4e8;">		考虑直接树套树，扫val&lt;=x，剩下的线段树套线段树</span></span>
<span class="line"><span style="color:#e1e4e8;">		</span></span>
<span class="line"><span style="color:#e1e4e8;">		假如在线动态呢？</span></span>
<span class="line"><span style="color:#e1e4e8;">			树套树可以直接修改</span></span>
<span class="line"><span style="color:#e1e4e8;">			这里将val&lt;=x作BIT那一维可能会更方便</span></span>
<span class="line"><span style="color:#e1e4e8;">	矩形加矩形查和：</span></span>
<span class="line"><span style="color:#e1e4e8;">		首先肯定差分，将矩形查差分成前缀矩形查（键值只有单点了）</span></span>
<span class="line"><span style="color:#e1e4e8;">		考虑一下矩形加的差分，本来想也这么差，但是不太好贡献</span></span>
<span class="line"><span style="color:#e1e4e8;">		可以差成：后缀矩形加</span></span>
<span class="line"><span style="color:#e1e4e8;">		考虑一个点(x,y,v)对一个询问(qx,qy)：</span></span>
<span class="line"><span style="color:#e1e4e8;">			lim:x&lt;=qx,y&lt;=qy</span></span>
<span class="line"><span style="color:#e1e4e8;">			贡献：</span></span>
<span class="line"><span style="color:#e1e4e8;">				(qx-x+1)*(qy-y+1)*v</span></span>
<span class="line"><span style="color:#e1e4e8;">				=( (qx+1)*(qy+1) - (x*(qy+1)+y*(qx+1)) + x*y )*v</span></span>
<span class="line"><span style="color:#e1e4e8;">		直接维护四个二维偏序即可，可以在线或离线，都是log</span></span>
<span class="line"><span style="color:#e1e4e8;">	先做矩形加，然后做矩形查最值：</span></span>
<span class="line"><span style="color:#e1e4e8;">		限制是二维的双向不等式，而且求最值不能差分</span></span>
<span class="line"><span style="color:#e1e4e8;">		树套树显然没有前途，主要是tag不好处理</span></span>
<span class="line"><span style="color:#e1e4e8;">		可以考虑分治，每次处理跨过中线的询问，然后将右半部分去掉</span></span>
<span class="line"><span style="color:#e1e4e8;">		首先考虑偏序做法，显然可以差分以后历史最值</span></span>
<span class="line"><span style="color:#e1e4e8;">		那么直接套用即可</span></span>
<span class="line"><span style="color:#e1e4e8;">	区间加、区间撤销上次加、单点查值（1e5级别）：</span></span>
<span class="line"><span style="color:#e1e4e8;">		可以看成每个点都有一个栈，每次可以区间push和区间pop，然后单点查栈中和</span></span>
<span class="line"><span style="color:#e1e4e8;">		线段树完蛋，看看根号做法，也不太行，因为撤销受限于时间顺序</span></span>
<span class="line"><span style="color:#e1e4e8;">		那么得转化一下，加上时间维</span></span>
<span class="line"><span style="color:#e1e4e8;">		但是注意操作有时间顺序，用不等式刻画有点问题，所以画出平面来考虑</span></span>
<span class="line"><span style="color:#e1e4e8;">		发现区间操作就是一条竖线，单点查值就是查横的线，从左到右看的</span></span>
<span class="line"><span style="color:#e1e4e8;">		考虑竖着扫，维护每个时间点对应的答案，每次查前缀</span></span>
<span class="line"><span style="color:#e1e4e8;">		容易发现这个可以类似括号匹配，区间维护已经匹配剩下的)))))(((((</span></span>
<span class="line"><span style="color:#e1e4e8;">		而右括号只要维护个数，左括号需要维护所有的值</span></span>
<span class="line"><span style="color:#e1e4e8;">		直接维护理论可行，但是还有单点修改以及前缀查，我们需要快速实现：</span></span>
<span class="line"><span style="color:#e1e4e8;">			删掉一段后缀左括号</span></span>
<span class="line"><span style="color:#e1e4e8;">			拼接两段左括号</span></span>
<span class="line"><span style="color:#e1e4e8;">			整段查询左括号对应的权值和</span></span>
<span class="line"><span style="color:#e1e4e8;">		好像只能平衡树，而且每个点都要存，所以要可持久化</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">问题描述：</span></span>
<span class="line"><span style="color:#24292e;">	很多DS问题最终会转化成一个很基本的问题：点的问题</span></span>
<span class="line"><span style="color:#24292e;">	常见的是：统计点数（能差分）/最优化点权（不能差分）</span></span>
<span class="line"><span style="color:#24292e;">	同时，问题会对合法的点进行抽象定义</span></span>
<span class="line"><span style="color:#24292e;">	那么，问题的难点就在于将抽象的合法限制以优的复杂度实现</span></span>
<span class="line"><span style="color:#24292e;">常识：</span></span>
<span class="line"><span style="color:#24292e;">	静态的k维问题的复杂度一般为log^(k-1)</span></span>
<span class="line"><span style="color:#24292e;">	动态的k维问题的复杂度一般为log^k</span></span>
<span class="line"><span style="color:#24292e;">整体思路：</span></span>
<span class="line"><span style="color:#24292e;">	核心：用尽可能少的log刻画出限制</span></span>
<span class="line"><span style="color:#24292e;">	有时，你容易提出一个log特别多的限制办法，这时重点就是想办法减少限制</span></span>
<span class="line"><span style="color:#24292e;">对限制的具体处理思路：</span></span>
<span class="line"><span style="color:#24292e;">	处理修改：</span></span>
<span class="line"><span style="color:#24292e;">		将时间维看成一维限制处理：</span></span>
<span class="line"><span style="color:#24292e;">			查询看成是对时间维的前缀修改点查询</span></span>
<span class="line"><span style="color:#24292e;">		直接在线修改处理</span></span>
<span class="line"><span style="color:#24292e;">	处理偏序（单限制不等式）：</span></span>
<span class="line"><span style="color:#24292e;">		离线：扫描线（即CDQ的一维形态），CDQ分治</span></span>
<span class="line"><span style="color:#24292e;">			离线带修可以将时间维看作一维限制</span></span>
<span class="line"><span style="color:#24292e;">		在线不带修：序列上可持久化结构（例如主席树）</span></span>
<span class="line"><span style="color:#24292e;">		在线带修：树状数组</span></span>
<span class="line"><span style="color:#24292e;">	处理一般不等式：</span></span>
<span class="line"><span style="color:#24292e;">		尝试套用偏序做法：</span></span>
<span class="line"><span style="color:#24292e;">			可以差分：差分后套偏序做法</span></span>
<span class="line"><span style="color:#24292e;">			扫描线可以结合带修DS使用</span></span>
<span class="line"><span style="color:#24292e;">			一般的：分治套偏序做法</span></span>
<span class="line"><span style="color:#24292e;">		树套树：</span></span>
<span class="line"><span style="color:#24292e;">			一维形态：线段树</span></span>
<span class="line"><span style="color:#24292e;">			BIT套SGT：一维偏序，一维双向</span></span>
<span class="line"><span style="color:#24292e;">			SGT套SGT（二维线段树）：两维双向</span></span>
<span class="line"><span style="color:#24292e;">		K-D tree</span></span>
<span class="line"><span style="color:#24292e;">	注意：</span></span>
<span class="line"><span style="color:#24292e;">		优先考虑离线做法，在线做法时空比较劣</span></span>
<span class="line"><span style="color:#24292e;">		并不一定要用时间维分析，因为时间维将修改操作一般化了，失去了特殊性</span></span>
<span class="line"><span style="color:#24292e;">处理限制的思考技巧：</span></span>
<span class="line"><span style="color:#24292e;">	一般化表示比较复杂，可以简单分类讨论：</span></span>
<span class="line"><span style="color:#24292e;">		情况变多了，但单个情况的条件变少了，去除了冗余条件</span></span>
<span class="line"><span style="color:#24292e;">	灵活转化/分裂/合并偏序限制和一般限制：</span></span>
<span class="line"><span style="color:#24292e;">		一般限制可以拆分成上下界的偏序限制</span></span>
<span class="line"><span style="color:#24292e;">			特别的，可差分的问题可以直接去掉一般限制</span></span>
<span class="line"><span style="color:#24292e;">		有时，多个偏序限制可以合并成一个一般限制</span></span>
<span class="line"><span style="color:#24292e;">	询问和点贡献方式互换：</span></span>
<span class="line"><span style="color:#24292e;">		有时询问贡献点更好处理，就要交换</span></span>
<span class="line"><span style="color:#24292e;">	其他的思考技巧就和分析性质相似了</span></span>
<span class="line"><span style="color:#24292e;">典例：</span></span>
<span class="line"><span style="color:#24292e;">	区间mex：</span></span>
<span class="line"><span style="color:#24292e;">		显然二分，问题就变成：&lt;=lim的所有数是否都在[l,r]中出现</span></span>
<span class="line"><span style="color:#24292e;">		出现可以刻画成：对于x的所有出现位置pos,存在l&lt;=pos&lt;=r</span></span>
<span class="line"><span style="color:#24292e;">		拆偏序处理，那么pos&lt;=r直接扫掉，条件就转化成max(pos)&gt;=l</span></span>
<span class="line"><span style="color:#24292e;">	给定若干区间[li,ri]以及对应权值ci，多次询问和[l,r]的交&gt;=k的区间的最小权值：</span></span>
<span class="line"><span style="color:#24292e;">		直接分析的话可以列出一堆条件，非常麻烦，考虑减少条件数</span></span>
<span class="line"><span style="color:#24292e;">		有交这个一般条件刻画复杂，考虑分类讨论：</span></span>
<span class="line"><span style="color:#24292e;">			完全包含，完全被包含，包含左端点，包含右端点</span></span>
<span class="line"><span style="color:#24292e;">		完全包含可以被最后两个替代，只剩三种情况</span></span>
<span class="line"><span style="color:#24292e;">		最后两个都是好做的，即二维偏序</span></span>
<span class="line"><span style="color:#24292e;">		完全被包含需要对长度和左右端点做限制，即：</span></span>
<span class="line"><span style="color:#24292e;">			l&lt;=li,ri&lt;=r,ri-lr+1&gt;=k</span></span>
<span class="line"><span style="color:#24292e;">		这并不足以通过，考虑再次优化条件</span></span>
<span class="line"><span style="color:#24292e;">		发现前两个偏序可以合并成对ri的双向限制，那么扫偏序再线段树处理双向限制即可</span></span>
<span class="line"><span style="color:#24292e;">	区间查询前驱：</span></span>
<span class="line"><span style="color:#24292e;">		问题可以刻画成：</span></span>
<span class="line"><span style="color:#24292e;">			每个点(pos,val)</span></span>
<span class="line"><span style="color:#24292e;">			lim：l&lt;=pos&lt;=r,val&lt;=x</span></span>
<span class="line"><span style="color:#24292e;">			aim：maximum(val)</span></span>
<span class="line"><span style="color:#24292e;">		观察到限制形态，直接有一个离线静态做法：</span></span>
<span class="line"><span style="color:#24292e;">			扫描掉偏序，剩下的用SGT</span></span>
<span class="line"><span style="color:#24292e;">		</span></span>
<span class="line"><span style="color:#24292e;">		假如离线动态呢？	将时间维也刻画出来：</span></span>
<span class="line"><span style="color:#24292e;">			每个点(tl,tr,pos,val)，询问(t,l,r,x)</span></span>
<span class="line"><span style="color:#24292e;">			lim：tl&lt;=t&lt;=tr,l&lt;=pos&lt;=r,val&lt;=x</span></span>
<span class="line"><span style="color:#24292e;">			aim:maximum(val)</span></span>
<span class="line"><span style="color:#24292e;">		一个办法是把一般不等式拆掉，应该是log^3</span></span>
<span class="line"><span style="color:#24292e;">		考虑直接树套树，扫val&lt;=x，剩下的线段树套线段树</span></span>
<span class="line"><span style="color:#24292e;">		</span></span>
<span class="line"><span style="color:#24292e;">		假如在线动态呢？</span></span>
<span class="line"><span style="color:#24292e;">			树套树可以直接修改</span></span>
<span class="line"><span style="color:#24292e;">			这里将val&lt;=x作BIT那一维可能会更方便</span></span>
<span class="line"><span style="color:#24292e;">	矩形加矩形查和：</span></span>
<span class="line"><span style="color:#24292e;">		首先肯定差分，将矩形查差分成前缀矩形查（键值只有单点了）</span></span>
<span class="line"><span style="color:#24292e;">		考虑一下矩形加的差分，本来想也这么差，但是不太好贡献</span></span>
<span class="line"><span style="color:#24292e;">		可以差成：后缀矩形加</span></span>
<span class="line"><span style="color:#24292e;">		考虑一个点(x,y,v)对一个询问(qx,qy)：</span></span>
<span class="line"><span style="color:#24292e;">			lim:x&lt;=qx,y&lt;=qy</span></span>
<span class="line"><span style="color:#24292e;">			贡献：</span></span>
<span class="line"><span style="color:#24292e;">				(qx-x+1)*(qy-y+1)*v</span></span>
<span class="line"><span style="color:#24292e;">				=( (qx+1)*(qy+1) - (x*(qy+1)+y*(qx+1)) + x*y )*v</span></span>
<span class="line"><span style="color:#24292e;">		直接维护四个二维偏序即可，可以在线或离线，都是log</span></span>
<span class="line"><span style="color:#24292e;">	先做矩形加，然后做矩形查最值：</span></span>
<span class="line"><span style="color:#24292e;">		限制是二维的双向不等式，而且求最值不能差分</span></span>
<span class="line"><span style="color:#24292e;">		树套树显然没有前途，主要是tag不好处理</span></span>
<span class="line"><span style="color:#24292e;">		可以考虑分治，每次处理跨过中线的询问，然后将右半部分去掉</span></span>
<span class="line"><span style="color:#24292e;">		首先考虑偏序做法，显然可以差分以后历史最值</span></span>
<span class="line"><span style="color:#24292e;">		那么直接套用即可</span></span>
<span class="line"><span style="color:#24292e;">	区间加、区间撤销上次加、单点查值（1e5级别）：</span></span>
<span class="line"><span style="color:#24292e;">		可以看成每个点都有一个栈，每次可以区间push和区间pop，然后单点查栈中和</span></span>
<span class="line"><span style="color:#24292e;">		线段树完蛋，看看根号做法，也不太行，因为撤销受限于时间顺序</span></span>
<span class="line"><span style="color:#24292e;">		那么得转化一下，加上时间维</span></span>
<span class="line"><span style="color:#24292e;">		但是注意操作有时间顺序，用不等式刻画有点问题，所以画出平面来考虑</span></span>
<span class="line"><span style="color:#24292e;">		发现区间操作就是一条竖线，单点查值就是查横的线，从左到右看的</span></span>
<span class="line"><span style="color:#24292e;">		考虑竖着扫，维护每个时间点对应的答案，每次查前缀</span></span>
<span class="line"><span style="color:#24292e;">		容易发现这个可以类似括号匹配，区间维护已经匹配剩下的)))))(((((</span></span>
<span class="line"><span style="color:#24292e;">		而右括号只要维护个数，左括号需要维护所有的值</span></span>
<span class="line"><span style="color:#24292e;">		直接维护理论可行，但是还有单点修改以及前缀查，我们需要快速实现：</span></span>
<span class="line"><span style="color:#24292e;">			删掉一段后缀左括号</span></span>
<span class="line"><span style="color:#24292e;">			拼接两段左括号</span></span>
<span class="line"><span style="color:#24292e;">			整段查询左括号对应的权值和</span></span>
<span class="line"><span style="color:#24292e;">		好像只能平衡树，而且每个点都要存，所以要可持久化</span></span></code></pre></div>`,2),t=[p];function o(c,r,i,y,x,m){return n(),a("div",null,t)}const v=s(e,[["render",o]]);export{d as __pageData,v as default};
