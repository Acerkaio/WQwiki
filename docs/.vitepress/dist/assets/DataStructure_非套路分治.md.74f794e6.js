import{_ as a,o as e,c as r,Q as l}from"./chunks/framework.e7363dcb.js";const b=JSON.parse('{"title":"非套路分治","description":"","frontmatter":{},"headers":[],"relativePath":"DataStructure/非套路分治.md","filePath":"DataStructure/非套路分治.md","lastUpdated":1738591681000}'),t={name:"DataStructure/非套路分治.md"},i=l('<h1 id="非套路分治" tabindex="-1">非套路分治 <a class="header-anchor" href="#非套路分治" aria-label="Permalink to &quot;非套路分治&quot;">​</a></h1><h2 id="分治概述" tabindex="-1">分治概述 <a class="header-anchor" href="#分治概述" aria-label="Permalink to &quot;分治概述&quot;">​</a></h2><p>很多时候，分治可以被带有分治结构的 DS 代替。但是分治是 DS 题最基本的方法，只要是一道题，基本上都可以用。</p><h2 id="分治的性质" tabindex="-1">分治的性质 <a class="header-anchor" href="#分治的性质" aria-label="Permalink to &quot;分治的性质&quot;">​</a></h2><p>我们以线段树的结构来分析分治的结构性质，记一个节点的大小为其对应线段长。</p><ul><li>层数只有 log 层。</li><li>所有节点的大小总和是 $n\\log n$。</li><li>每个节点的子树大小和为 $n\\log^2 n$。</li><li>每个节点的两个子节点的大小几乎相等。</li></ul><h2 id="分治的常见运用" tabindex="-1">分治的常见运用 <a class="header-anchor" href="#分治的常见运用" aria-label="Permalink to &quot;分治的常见运用&quot;">​</a></h2><h3 id="优化背包合并的复杂度" tabindex="-1">优化背包合并的复杂度 <a class="header-anchor" href="#优化背包合并的复杂度" aria-label="Permalink to &quot;优化背包合并的复杂度&quot;">​</a></h3><p>闵可夫斯基和，FFT 都可以用此优化。有时也可以写成倍增形态。</p><h3 id="去掉一维偏序" tabindex="-1">去掉一维偏序 <a class="header-anchor" href="#去掉一维偏序" aria-label="Permalink to &quot;去掉一维偏序&quot;">​</a></h3><p>即 CDQ 分治。在某些问题中也可以处理修改操作，例如点的统计问题。</p><h3 id="处理一般的多次询问问题" tabindex="-1">处理一般的多次询问问题 <a class="header-anchor" href="#处理一般的多次询问问题" aria-label="Permalink to &quot;处理一般的多次询问问题&quot;">​</a></h3><p>核心：将跨过中线的询问去掉一半，然后将另一半以及其他的询问继续递归。例如：跳端点分治。</p><h2 id="例题" tabindex="-1">例题 <a class="header-anchor" href="#例题" aria-label="Permalink to &quot;例题&quot;">​</a></h2><h3 id="arc184b" tabindex="-1">ARC184B <a class="header-anchor" href="#arc184b" aria-label="Permalink to &quot;ARC184B&quot;">​</a></h3><p>观察到当序列中的某一种元素已经大于假币数量时，我们就可以确定这个序列那些是假币。所以要让序列尽可能长，联想到分治的平衡结构，尝试分治。考虑正确性，只要序列长度 &gt; $2m$，那么序列就一定能确定，所以至少可以减少 $1000 / 20 = 50$ 次询问。</p><h3 id="gym102331j" tabindex="-1">Gym102331J <a class="header-anchor" href="#gym102331j" aria-label="Permalink to &quot;Gym102331J&quot;">​</a></h3><p>显然有背包 + 闵可夫斯基和的做法，复杂度 $O(N^2)$。考虑到本题不太有其他做法，所以尝试优化当前做法。瓶颈在闵可夫斯基和，发现复杂度就是每棵子树的大小乘上其合并的次数再求和。联想到分治的层数少，可以尝试用分治合并。但是复杂度还是不对，因为每个子树都被合并了一遍。联想到启发式，分一下轻重儿子，轻儿子分治合并，重儿子在重链上分治合并。</p><h3 id="rqrmq1" tabindex="-1">rqrmq1 <a class="header-anchor" href="#rqrmq1" aria-label="Permalink to &quot;rqrmq1&quot;">​</a></h3><p>略</p><h2 id="整体二分" tabindex="-1">整体二分 <a class="header-anchor" href="#整体二分" aria-label="Permalink to &quot;整体二分&quot;">​</a></h2><h3 id="适用情况" tabindex="-1">适用情况 <a class="header-anchor" href="#适用情况" aria-label="Permalink to &quot;适用情况&quot;">​</a></h3><p>不强制在线，所有询问都能用二分解决（可以有单点修改）。</p><h3 id="此类问题的常见思路" tabindex="-1">此类问题的常见思路 <a class="header-anchor" href="#此类问题的常见思路" aria-label="Permalink to &quot;此类问题的常见思路&quot;">​</a></h3><ul><li>每个询问二分：复杂度平方对数。</li><li>暴力均摊：复杂度平方。</li><li>整体二分：主体随二分的范围变小而变小，复杂度线性对数。</li></ul><h3 id="整体二分的重要性质" tabindex="-1">整体二分的重要性质 <a class="header-anchor" href="#整体二分的重要性质" aria-label="Permalink to &quot;整体二分的重要性质&quot;">​</a></h3><p>同一层保证二分的值单调递增，可以一起处理。</p><h2 id="刷题" tabindex="-1">刷题 <a class="header-anchor" href="#刷题" aria-label="Permalink to &quot;刷题&quot;">​</a></h2><h3 id="区间-k-大值" tabindex="-1">区间 k 大值 <a class="header-anchor" href="#区间-k-大值" aria-label="Permalink to &quot;区间 k 大值&quot;">​</a></h3><p>经典题，想怎么做就怎么做。如果带修呢？将修改看作减掉一个点和加上一个点，和询问一起按时间放进操作序列，然后每次按值域分治操作。</p><h3 id="多次询问无向图任意两点的-min-max-最短路" tabindex="-1">多次询问无向图任意两点的 min/max 最短路 <a class="header-anchor" href="#多次询问无向图任意两点的-min-max-最短路" aria-label="Permalink to &quot;多次询问无向图任意两点的 min/max 最短路&quot;">​</a></h3><p>kruskal 重构树板子，但整体二分也能做，结合一下可撤销并查集，每次只加入 &lt;= mid 的边。</p><h2 id="图分治" tabindex="-1">图分治 <a class="header-anchor" href="#图分治" aria-label="Permalink to &quot;图分治&quot;">​</a></h2><p>专门处理网格图上的抽象问题。例如：</p><ul><li>多次查询。</li><li>最优化子矩形。</li></ul><h2 id="例题-1" tabindex="-1">例题 <a class="header-anchor" href="#例题-1" aria-label="Permalink to &quot;例题&quot;">​</a></h2><ul><li>ZJOI 旅行者。</li><li>各种关于子矩形的题目。</li></ul>',37),h=[i];function o(n,d,c,s,u,q){return e(),r("div",null,h)}const p=a(t,[["render",o]]);export{b as __pageData,p as default};
