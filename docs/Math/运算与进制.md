把这些转为markdown源码给我：
# 运算与进制
```
逻辑运算（只有01的运算）：
	逻辑运算是所有运算的基础，可以实现所有的运算
	逻辑运算的基本运算符：与，非
	逻辑运算的重要运算符：或，异或
	核心性质：所有逻辑运算符都可由核心运算符（与，非）表达
	和其他高级运算的关系：
		逻辑运算可以看作在取模2的意义下的一般整数运算
		拥有一般整数运算的所有性质
		具体的，加/减 对应 异或，乘 对应 与
		
		推广结论：异或的结果的奇偶性和加法结果的奇偶性相同
	
	这是位运算的基础，分析位运算的性质通常都可以通过按位分解转换成逻辑运算的分析
处理位运算的常见办法：
	01trie：分析性质常用
	按位分解：分析性质或计算答案
		此时只需考虑01的贡献，可以利用逻辑运算的性质
	高维前缀和，fwt：允许状压时的常见办法
	线性基：
		1.判断一个数能否被一个集合中的数异或出来
		2.得到整个集合能异或出多少个数
	
	二进制位互相不独立的处理：
		不等号：
			钦定前k位都取等，然后考虑k+1位不取等
			将不取等的情况去掉，然后继续递归
		加减法：
			加法可以看成异或+进位，不同位之间的影响只有进位
			分析进位的条件，一般情况是有大小限制
			分类考虑是否进位，从而实现拆位考虑
			减法分析退位即可，是相似的
			
			具体实现：
				对于第k位考虑时，一种较通用办法是将所有运算都放在模2^(k+1)下考虑，这样容易刻画进位
				否则，需要具体问题具体分析

位运算的常见性质：
	位运算与集合的关系：
		x&y==y || x|y==x -> y是x的子集
		ful^x -> x的补集
	各个位运算的关系：
		!(x&y)=(!x)|(!y)
		利用补集（非），与和或可以互相转化
		
		xor可以被补集 和 与（或）表示出来
		但是，xor不能表示其他任何运算
		
		综上，所有位运算只需要保留 非 与
		这可以用来考虑有多种位运算结合的问题
	位运算和高级运算的关系：
		对应关系-相似性质：
			加/减 对应 异或，乘 对应 与
			证明考虑用逻辑运算性质分析（模2意义下）
			那么 加法 乘法 的运算关系可以完全和 异或 与 等价
			经典的：
				乘法相对于加法的分配律：与相对于异或的分配律
				加乘矩阵的结合律：异或-与矩阵的结合律
		异或和加法的关系：
			异或等价于不进位加法
			加法和异或转换时核心在于分析是否进位
		异或和加减法的不等关系：
			x-y<= x xor y <=x+y
			
			x-y==x xor y 当且仅当y是x的子集
			x+y==x xor y 当且仅当y和x互补
	异或的常见性质：
		自反性，交换律（无序性），可减性
		一个集合的必然存在最小异或点对在值域上相邻
		xor变换性质：
			形象化的讲，是一条双向边，两两配对
			集合{1~(2^k-1)}中的每个元素异或上x(0<=x<2^k)后集合不变

原码和补码：
	定义：
		原码就是有符号二进制数
		补码就是有符号二进制数在模2^k的意义下对应的非负数
			其中，k是根据变量存储类型决定的
	性质：
		x的补码和-x的补码的最低位相同
			因为相加和为0，所以自然相同
		非负数的补码必然最高位是0，负数的补码必然最高位是1
	作用：
		利用补码，我们不用考虑减法和加法的差异，可以一律使用加法考虑问题
		这对于我们上述二进制加减法的分析有所裨益

任意进制下的规律：
	数的表示：
		x=a0*p^0+a1*p^1+a2*p^2+...
		其中，a0,a1,a2,...范围是[0,p-1]
		
		可以发现，这是一个条件更强的多项式
		所以数的运算可以看作由两部分组成：
			多项式运算（加法、卷积）
			保证系数范围限制的进退位
	加减法：
		对应的多项式运算是多项式加法
		
		任何进制下，两个数相加的进位最多是1
		任何进制下，两个数相减的退位最多是1
	乘法：
		对应的多项式运算是卷积
		
		任何进制下，两个数相乘的位数（从1开始）最多x+y
		卷积过后，多项式系数的最大值为 (p-1)^2*(较小的数的位数）
		
		具体实现：复杂度瓶颈在卷积，可以用NTT优化
	除法：
		对应的多项式运算是多项式除法
		实际实现可以模拟竖式除法
			竖式除法正确性可以利用反证法证明
	
	利用以上分析，容易实现朴素的高精度

例题：
	YNOI fusion tree：
		难点在+1，考虑到进位的条件是低位前缀都是1，所以要特别处理这种情况
		显然可以从低向高建trie树，每次处理从上到下递归即可
	自己想的题：
		全局加：a[i]+=x
		插入数
		删除数
		求全局异或和
		
		solution:
			对于每一位分别考虑，将操作置于模意义下
			可以通过记全局tag实现全局加
				那减完tag出现负数怎么办？利用补码考虑即可
			那么查询可以列出范围，然后BIT求解即可
求集合最大按位与（或）点对：高维前缀和
求集合最大异或点对：trie树

联考题：
	给定若干数，每个数形如若干段1和0拼起来的，
	操作可以将集合中的任意两个数做 与，或，异或，或是 取反
	问有多少个2的非负整数次幂能表示出来
	
	solution:
	显然，只有与和非有用
	过程太难分析，直接考虑找必要条件
	不合法的时候，必然有两个点的覆盖的样子一样
	那么显然覆盖样子不同是必要的
	感觉也很有充分性，看看怎么构造
	（有难度）将没有覆盖的取反，然后将所有都取交，易证合法
	

```