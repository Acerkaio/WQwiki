import{_ as a,o as i,c as e,Q as l}from"./chunks/framework.e7363dcb.js";const k=JSON.parse('{"title":"计数杂项","description":"","frontmatter":{},"headers":[],"relativePath":"Mad/计数/计数杂项.md","filePath":"Mad/计数/计数杂项.md","lastUpdated":1738666900000}'),r={name:"Mad/计数/计数杂项.md"},t=l('<h1 id="计数杂项" tabindex="-1">计数杂项 <a class="header-anchor" href="#计数杂项" aria-label="Permalink to &quot;计数杂项&quot;">​</a></h1><h2 id="组合恒等式" tabindex="-1">组合恒等式 <a class="header-anchor" href="#组合恒等式" aria-label="Permalink to &quot;组合恒等式&quot;">​</a></h2><h3 id="推导组合恒等式的常见办法" tabindex="-1">推导组合恒等式的常见办法 <a class="header-anchor" href="#推导组合恒等式的常见办法" aria-label="Permalink to &quot;推导组合恒等式的常见办法&quot;">​</a></h3><ul><li><strong>组合意义</strong>：一般更方便</li><li><strong>二项式定理</strong>：处理行的和</li><li><strong>利用已有恒等式推导</strong></li></ul><h3 id="常见式子" tabindex="-1">常见式子 <a class="header-anchor" href="#常见式子" aria-label="Permalink to &quot;常见式子&quot;">​</a></h3><h4 id="基本定义" tabindex="-1">基本定义 <a class="header-anchor" href="#基本定义" aria-label="Permalink to &quot;基本定义&quot;">​</a></h4><ul><li>$A(n,i)$即$n$的下降幂</li><li>$C(n,j)=\\frac{A(n,j)}{A(j,j)}=\\frac{n!}{j!(n - j)!}$</li></ul><h4 id="对称性" tabindex="-1">对称性 <a class="header-anchor" href="#对称性" aria-label="Permalink to &quot;对称性&quot;">​</a></h4><p>$C(n,i)=C(n,n - i)$</p><h4 id="加法分解" tabindex="-1">加法分解 <a class="header-anchor" href="#加法分解" aria-label="Permalink to &quot;加法分解&quot;">​</a></h4><ul><li>$C(n,i)=C(n - 1,i - 1)+C(n - 1,i)$</li><li>$A(n,i)=A(n - 1,i)+i\\times A(n - 1,i - 1)$</li><li>$C(n,i)=\\sum_{j = i - 1}^{n - 1} C(j,i - 1)$</li></ul><h4 id="乘法转换" tabindex="-1">乘法转换 <a class="header-anchor" href="#乘法转换" aria-label="Permalink to &quot;乘法转换&quot;">​</a></h4><ul><li>$A(n,i)=A(n,j)\\times A(n - j,i - j)$</li><li>$C(n,i)\\times A(i,j)=C(n - j,i - j)\\times A(n,j)$</li><li>$C(n,i)\\times C(i,j)=C(n,j)\\times C(n - j,i - j)$</li></ul><h4 id="利用二项式定理巧妙赋值" tabindex="-1">利用二项式定理巧妙赋值 <a class="header-anchor" href="#利用二项式定理巧妙赋值" aria-label="Permalink to &quot;利用二项式定理巧妙赋值&quot;">​</a></h4><ul><li>$C(n,\\text{奇}) = C(n,\\text{偶})$</li><li>$\\sum_{i} C(n,i)=2^n$</li></ul><h2 id="二项式反演" tabindex="-1">二项式反演 <a class="header-anchor" href="#二项式反演" aria-label="Permalink to &quot;二项式反演&quot;">​</a></h2><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><p>若$f[n]=\\sum_{i} C(i,n)\\times g[i]$，则$g[n]=\\sum_{i} (-1)^{(i - n)}\\times C(i,n)\\times f[i]$</p><h3 id="判断正确性的依据" tabindex="-1">判断正确性的依据 <a class="header-anchor" href="#判断正确性的依据" aria-label="Permalink to &quot;判断正确性的依据&quot;">​</a></h3><p>“至少”是否满足和“恰好”的关系，满足就可以用</p><h3 id="实现相关" tabindex="-1">实现相关 <a class="header-anchor" href="#实现相关" aria-label="Permalink to &quot;实现相关&quot;">​</a></h3><h4 id="法一" tabindex="-1">法一 <a class="header-anchor" href="#法一" aria-label="Permalink to &quot;法一&quot;">​</a></h4><p>已经得到$g$的情况下，可以利用卷积实现二项式反演。直接暴力卷积是平方的，利用$ntt$是线性对数的。</p><h4 id="法二-一般模数" tabindex="-1">法二（一般模数） <a class="header-anchor" href="#法二-一般模数" aria-label="Permalink to &quot;法二（一般模数）&quot;">​</a></h4><p>需要将答案式写出，进行进一步的推式子和优化。</p><h3 id="k-维二项式反演" tabindex="-1">$k$维二项式反演 <a class="header-anchor" href="#k-维二项式反演" aria-label="Permalink to &quot;$k$维二项式反演&quot;">​</a></h3><h4 id="类比理解" tabindex="-1">类比理解 <a class="header-anchor" href="#类比理解" aria-label="Permalink to &quot;类比理解&quot;">​</a></h4><p>高维前缀和与其逆变换</p><h4 id="具体处理" tabindex="-1">具体处理 <a class="header-anchor" href="#具体处理" aria-label="Permalink to &quot;具体处理&quot;">​</a></h4><p>对每一维分别做二项式反演即可</p><h4 id="复杂度" tabindex="-1">复杂度 <a class="header-anchor" href="#复杂度" aria-label="Permalink to &quot;复杂度&quot;">​</a></h4><p>$k\\times$单次二项式反演复杂度</p><h4 id="常见应用" tabindex="-1">常见应用 <a class="header-anchor" href="#常见应用" aria-label="Permalink to &quot;常见应用&quot;">​</a></h4><ul><li>（容斥）去掉一个条件</li><li>处理恰好$k$个的条件</li></ul><h2 id="斯特林数" tabindex="-1">斯特林数 <a class="header-anchor" href="#斯特林数" aria-label="Permalink to &quot;斯特林数&quot;">​</a></h2><p>以下记第二类斯特林数为$S$</p><h3 id="s-n-k-的组合意义" tabindex="-1">$S(n,k)$的组合意义 <a class="header-anchor" href="#s-n-k-的组合意义" aria-label="Permalink to &quot;$S(n,k)$的组合意义&quot;">​</a></h3><p>将$n$个不同的球恰分成$k$组的方案数。其中，两个方案不同当且仅当存在两个球在其中一个方案中在同一个组中，在另一个方案中不在同一个组中。</p><h3 id="辨" tabindex="-1">辨 <a class="header-anchor" href="#辨" aria-label="Permalink to &quot;辨&quot;">​</a></h3><ul><li>将$n$个不同的球放进$k$个不同盘子（允许放空）的方案数是$k^n$</li><li>将$n$个不同的球放进$k$个相同盘子（不允许放空）的方案数是$S(n,k)$</li></ul><h3 id="递推公式" tabindex="-1">递推公式 <a class="header-anchor" href="#递推公式" aria-label="Permalink to &quot;递推公式&quot;">​</a></h3><p>$S(n,k)= S(n - 1,k - 1)+S(n - 1,k)\\times k$</p><p><strong>proof</strong>：考虑$S(n,k)$的所有方案中第$n$个球的情况，是否是自己一个组，证明双射即可。</p><h3 id="通项公式" tabindex="-1">通项公式 <a class="header-anchor" href="#通项公式" aria-label="Permalink to &quot;通项公式&quot;">​</a></h3><p>$S(n,k)=\\sum_{i} (-1)^{(k - i)} \\times \\frac{i^n}{k! \\times (k - i)!}$</p><p><strong>proof</strong>：发现无标号可放空是好算的，直接容斥即可。</p><h3 id="普通幂转下降幂" tabindex="-1">普通幂转下降幂 <a class="header-anchor" href="#普通幂转下降幂" aria-label="Permalink to &quot;普通幂转下降幂&quot;">​</a></h3><p>$k^n=\\sum_{i} A(k,i)\\times S(n,i)$</p><h2 id="prufer序列" tabindex="-1">prufer序列 <a class="header-anchor" href="#prufer序列" aria-label="Permalink to &quot;prufer序列&quot;">​</a></h2><h3 id="构造" tabindex="-1">构造 <a class="header-anchor" href="#构造" aria-label="Permalink to &quot;构造&quot;">​</a></h3><p>每次选出编号最小的度数为$1$的节点，将其删去，并将其父节点加入序列。</p><h3 id="性质" tabindex="-1">性质 <a class="header-anchor" href="#性质" aria-label="Permalink to &quot;性质&quot;">​</a></h3><ul><li>序列和有标号有根树一一对应</li><li>点$i$的出现次数等于其度数减$1$</li><li>构造时最终剩下的两个节点有一个是$n$</li></ul><h3 id="重要推论" tabindex="-1">重要推论 <a class="header-anchor" href="#重要推论" aria-label="Permalink to &quot;重要推论&quot;">​</a></h3><p>图中有$k$个连通块，其大小分别为$a[1\\sim k]$，添加$k - 1$条边将其连成一个连通图的方案数为$n^{k - 2} \\times (a[1]\\times a[2]\\times\\cdots\\times a[k])$</p><p><strong>理性理解</strong>：</p><ul><li>不妨先统计有根树的数量，最后除以$n$即可。</li><li>将$prufer$序列改一下变成每次删的对应的具体连的父亲节点。</li><li>然后再钦定一下删除当前块连给父亲的是哪个点，钦定最后一个删除块钦定的点就是根。</li><li>那么发现这应该可以一一对应，就证完了。</li></ul><h2 id="生成函数简陋知识" tabindex="-1">生成函数简陋知识 <a class="header-anchor" href="#生成函数简陋知识" aria-label="Permalink to &quot;生成函数简陋知识&quot;">​</a></h2><ul><li>$\\frac{1}{(1 - x)^k}=\\sum_{i} C(i + k - 1,k - 1)\\times x^i$</li><li>$\\frac{x^n}{1 - x}=\\sum_{i = 0}^{n - 1} x^i$</li><li>$e^x=\\sum_{i} \\frac{x^i}{i!}$</li><li>$OGF$和$EGF$的卷积</li></ul>',59),n=[t];function o(h,s,d,$,u,c){return i(),e("div",null,n)}const b=a(r,[["render",o]]);export{k as __pageData,b as default};
