import{_ as l,o as i,c as a,Q as t}from"./chunks/framework.e7363dcb.js";const q=JSON.parse('{"title":"处理带限制的点","description":"","frontmatter":{},"headers":[],"relativePath":"DataStructure/处理带限制的点.md","filePath":"DataStructure/处理带限制的点.md","lastUpdated":1740448168000}'),r={name:"DataStructure/处理带限制的点.md"},e=t('<h1 id="处理带限制的点" tabindex="-1">处理带限制的点 <a class="header-anchor" href="#处理带限制的点" aria-label="Permalink to &quot;处理带限制的点&quot;">​</a></h1><h2 id="问题描述" tabindex="-1">问题描述 <a class="header-anchor" href="#问题描述" aria-label="Permalink to &quot;问题描述&quot;">​</a></h2><p>很多 DS 问题最终会转化成一个很基本的问题：点的问题。 常见的是：统计点数（能差分）/最优化点权（不能差分）。 同时，问题会对合法的点进行抽象定义。 那么，问题的难点就在于将抽象的合法限制以优的复杂度实现。</p><h2 id="常识" tabindex="-1">常识 <a class="header-anchor" href="#常识" aria-label="Permalink to &quot;常识&quot;">​</a></h2><ul><li>静态的 k 维问题的复杂度一般为 $log^{(k - 1)}$。</li><li>动态的 k 维问题的复杂度一般为 $log^k$。</li></ul><h2 id="整体思路" tabindex="-1">整体思路 <a class="header-anchor" href="#整体思路" aria-label="Permalink to &quot;整体思路&quot;">​</a></h2><p>核心：用尽可能少的 $log$ 刻画出限制。 有时，你容易提出一个 $log$ 特别多的限制办法，这时重点就是想办法减少限制。</p><h2 id="对限制的具体处理思路" tabindex="-1">对限制的具体处理思路 <a class="header-anchor" href="#对限制的具体处理思路" aria-label="Permalink to &quot;对限制的具体处理思路&quot;">​</a></h2><h3 id="处理修改" tabindex="-1">处理修改 <a class="header-anchor" href="#处理修改" aria-label="Permalink to &quot;处理修改&quot;">​</a></h3><ul><li><strong>将时间维看成一维限制处理</strong>：查询看成是对时间维的前缀修改点查询。</li><li><strong>直接在线修改处理</strong>。</li></ul><h3 id="处理偏序-单限制不等式" tabindex="-1">处理偏序（单限制不等式） <a class="header-anchor" href="#处理偏序-单限制不等式" aria-label="Permalink to &quot;处理偏序（单限制不等式）&quot;">​</a></h3><ul><li><strong>离线</strong>：扫描线（即 CDQ 的一维形态），CDQ 分治。离线带修可以将时间维看作一维限制。</li><li><strong>在线不带修</strong>：序列上可持久化结构（例如主席树）。</li><li><strong>在线带修</strong>：树状数组。</li></ul><h3 id="处理一般不等式" tabindex="-1">处理一般不等式 <a class="header-anchor" href="#处理一般不等式" aria-label="Permalink to &quot;处理一般不等式&quot;">​</a></h3><ul><li><strong>尝试套用偏序做法</strong>： <ul><li>可以差分：差分后套偏序做法。</li><li>扫描线可以结合带修 DS 使用。</li><li>一般的：分治套偏序做法。</li></ul></li><li><strong>树套树</strong>： <ul><li>一维形态：线段树。</li><li>BIT 套 SGT：一维偏序，一维双向。</li><li>SGT 套 SGT（二维线段树）：两维双向。</li></ul></li><li><strong>K - D tree</strong></li></ul><h3 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意&quot;">​</a></h3><ul><li>优先考虑离线做法，在线做法时空比较劣。</li><li>并不一定要用时间维分析，因为时间维将修改操作一般化了，失去了特殊性。</li></ul><h2 id="处理限制的思考技巧" tabindex="-1">处理限制的思考技巧 <a class="header-anchor" href="#处理限制的思考技巧" aria-label="Permalink to &quot;处理限制的思考技巧&quot;">​</a></h2><ul><li><strong>一般化表示比较复杂，可以简单分类讨论</strong>：情况变多了，但单个情况的条件变少了，去除了冗余条件。</li><li><strong>灵活转化/分裂/合并偏序限制和一般限制</strong>： <ul><li>一般限制可以拆分成上下界的偏序限制。特别的，可差分的问题可以直接去掉一般限制。</li><li>有时，多个偏序限制可以合并成一个一般限制。</li></ul></li><li><strong>询问和点贡献方式互换</strong>：有时询问贡献点更好处理，就要交换。</li><li>其他的思考技巧就和分析性质相似了。</li></ul><h2 id="典例" tabindex="-1">典例 <a class="header-anchor" href="#典例" aria-label="Permalink to &quot;典例&quot;">​</a></h2><h3 id="区间-mex" tabindex="-1">区间 mex <a class="header-anchor" href="#区间-mex" aria-label="Permalink to &quot;区间 mex&quot;">​</a></h3><ul><li>显然二分，问题就变成：$&lt;=lim$ 的所有数是否都在 $[l, r]$ 中出现。</li><li>出现可以刻画成：对于 $x$ 的所有出现位置 $pos$，存在 $l &lt;= pos &lt;= r$。</li><li>拆偏序处理，那么 $pos &lt;= r$ 直接扫掉，条件就转化成 $max(pos) &gt;= l$。</li></ul><h3 id="给定若干区间-l-i-r-i-以及对应权值-c-i-多次询问和-l-r-的交-k-的区间的最小权值" tabindex="-1">给定若干区间 $[l_i, r_i]$ 以及对应权值 $c_i$，多次询问和 $[l, r]$ 的交 $&gt;= k$ 的区间的最小权值 <a class="header-anchor" href="#给定若干区间-l-i-r-i-以及对应权值-c-i-多次询问和-l-r-的交-k-的区间的最小权值" aria-label="Permalink to &quot;给定若干区间 $[l_i, r_i]$ 以及对应权值 $c_i$，多次询问和 $[l, r]$ 的交 $&gt;= k$ 的区间的最小权值&quot;">​</a></h3><ul><li>直接分析的话可以列出一堆条件，非常麻烦，考虑减少条件数。</li><li>有交这个一般条件刻画复杂，考虑分类讨论： <ul><li>完全包含，完全被包含，包含左端点，包含右端点。</li><li>完全包含可以被最后两个替代，只剩三种情况。</li><li>最后两个都是好做的，即二维偏序。</li><li>完全被包含需要对长度和左右端点做限制，即：$l &lt;= l_i$，$r_i &lt;= r$，$r_i - l_i + 1 &gt;= k$。</li><li>这并不足以通过，考虑再次优化条件。</li><li>发现前两个偏序可以合并成对 $r_i$ 的双向限制，那么扫偏序再线段树处理双向限制即可。</li></ul></li></ul><h3 id="区间查询前驱" tabindex="-1">区间查询前驱 <a class="header-anchor" href="#区间查询前驱" aria-label="Permalink to &quot;区间查询前驱&quot;">​</a></h3><ul><li><strong>问题刻画</strong>： <ul><li>每个点 $(pos, val)$。</li><li>$lim$：$l &lt;= pos &lt;= r$，$val &lt;= x$。</li><li>$aim$：$maximum(val)$。</li></ul></li><li><strong>离线静态做法</strong>：观察到限制形态，直接扫描掉偏序，剩下的用 SGT。</li><li><strong>离线动态做法</strong>： <ul><li>将时间维也刻画出来：每个点 $(t_l, t_r, pos, val)$，询问 $(t, l, r, x)$。</li><li>$lim$：$t_l &lt;= t &lt;= t_r$，$l &lt;= pos &lt;= r$，$val &lt;= x$。</li><li>$aim$：$maximum(val)$。</li><li>一个办法是把一般不等式拆掉，应该是 $log^3$。</li><li>考虑直接树套树，扫 $val &lt;= x$，剩下的线段树套线段树。</li></ul></li><li><strong>在线动态做法</strong>：树套树可以直接修改，这里将 $val &lt;= x$ 作 BIT 那一维可能会更方便。</li></ul><h3 id="矩形加矩形查和" tabindex="-1">矩形加矩形查和 <a class="header-anchor" href="#矩形加矩形查和" aria-label="Permalink to &quot;矩形加矩形查和&quot;">​</a></h3><ul><li>首先肯定差分，将矩形查差分成前缀矩形查（键值只有单点了）。</li><li>考虑一下矩形加的差分，本来想也这么差，但是不太好贡献，可以差成：后缀矩形加。</li><li>考虑一个点 $(x, y, v)$ 对一个询问 $(q_x, q_y)$： <ul><li>$lim$：$x &lt;= q_x$，$y &lt;= q_y$。</li><li>贡献：$(q_x - x + 1) * (q_y - y + 1) * v=( (q_x + 1) * (q_y + 1) - (x * (q_y + 1)+y * (q_x + 1)) + x * y ) * v$。</li><li>直接维护四个二维偏序即可，可以在线或离线，都是 $log$。</li></ul></li></ul><h3 id="先做矩形加-然后做矩形查最值" tabindex="-1">先做矩形加，然后做矩形查最值 <a class="header-anchor" href="#先做矩形加-然后做矩形查最值" aria-label="Permalink to &quot;先做矩形加，然后做矩形查最值&quot;">​</a></h3><ul><li>限制是二维的双向不等式，而且求最值不能差分。</li><li>树套树显然没有前途，主要是 tag 不好处理。</li><li>可以考虑分治，每次处理跨过中线的询问，然后将右半部分去掉。</li><li>首先考虑偏序做法，显然可以差分以后历史最值，那么直接套用即可。</li></ul><h3 id="区间加、区间撤销上次加、单点查值-1e5-级别" tabindex="-1">区间加、区间撤销上次加、单点查值（$1e5$ 级别） <a class="header-anchor" href="#区间加、区间撤销上次加、单点查值-1e5-级别" aria-label="Permalink to &quot;区间加、区间撤销上次加、单点查值（$1e5$ 级别）&quot;">​</a></h3><ul><li>可以看成每个点都有一个栈，每次可以区间 push 和区间 pop，然后单点查栈中和。</li><li>线段树完蛋，看看根号做法，也不太行，因为撤销受限于时间顺序。</li><li>那么得转化一下，加上时间维。</li><li>但是注意操作有时间顺序，用不等式刻画有点问题，所以画出平面来考虑。</li><li>发现区间操作就是一条竖线，单点查值就是查横的线，从左到右看的。</li><li>考虑竖着扫，维护每个时间点对应的答案，每次查前缀。</li><li>容易发现这个可以类似括号匹配，区间维护已经匹配剩下的 ))))((((。</li><li>而右括号只要维护个数，左括号需要维护所有的值。</li><li>直接维护理论可行，但是还有单点修改以及前缀查，我们需要快速实现： <ul><li>删掉一段后缀左括号。</li><li>拼接两段左括号。</li><li>整段查询左括号对应的权值和。</li></ul></li><li>好像只能平衡树，而且每个点都要存，所以要可持久化。</li></ul>',31),o=[e];function $(n,s,h,u,d,c){return i(),a("div",null,o)}const m=l(r,[["render",$]]);export{q as __pageData,m as default};
