import{_ as a,o as l,c as e,Q as i}from"./chunks/framework.e7363dcb.js";const m=JSON.parse('{"title":"数据结构问题","description":"","frontmatter":{},"headers":[],"relativePath":"DataStructure/数据结构问题.md","filePath":"DataStructure/数据结构问题.md","lastUpdated":1738591681000}'),r={name:"DataStructure/数据结构问题.md"},o=i('<h1 id="数据结构问题" tabindex="-1">数据结构问题 <a class="header-anchor" href="#数据结构问题" aria-label="Permalink to &quot;数据结构问题&quot;">​</a></h1><h2 id="处理区间问题的常见办法" tabindex="-1">处理区间问题的常见办法 <a class="header-anchor" href="#处理区间问题的常见办法" aria-label="Permalink to &quot;处理区间问题的常见办法&quot;">​</a></h2><h3 id="差分" tabindex="-1">差分 <a class="header-anchor" href="#差分" aria-label="Permalink to &quot;差分&quot;">​</a></h3><p>前缀和，主席树。</p><h3 id="线段树" tabindex="-1">线段树 <a class="header-anchor" href="#线段树" aria-label="Permalink to &quot;线段树&quot;">​</a></h3><ul><li>首先考虑区间维护什么信息，如何 <code>push_up</code>。</li><li>若有区间修改，考虑如何打 <code>tag</code>，如何快速修改区间信息。</li></ul><h3 id="分块" tabindex="-1">分块 <a class="header-anchor" href="#分块" aria-label="Permalink to &quot;分块&quot;">​</a></h3><ul><li>序列分块，时间轴分块。</li><li>优化暴力。</li></ul><h3 id="莫队" tabindex="-1">莫队 <a class="header-anchor" href="#莫队" aria-label="Permalink to &quot;莫队&quot;">​</a></h3><p>考虑左右端点的扩展和收缩如何维护答案。</p><h3 id="定右端点扫描线" tabindex="-1">定右端点扫描线 <a class="header-anchor" href="#定右端点扫描线" aria-label="Permalink to &quot;定右端点扫描线&quot;">​</a></h3><p>没有修改时的首选算法。</p><h3 id="跳端点-的询问" tabindex="-1">“跳端点”的询问 <a class="header-anchor" href="#跳端点-的询问" aria-label="Permalink to &quot;“跳端点”的询问&quot;">​</a></h3><p>倍增，跳端点分治。</p><h2 id="可撤销相关" tabindex="-1">可撤销相关 <a class="header-anchor" href="#可撤销相关" aria-label="Permalink to &quot;可撤销相关&quot;">​</a></h2><h3 id="任意顺序" tabindex="-1">任意顺序 <a class="header-anchor" href="#任意顺序" aria-label="Permalink to &quot;任意顺序&quot;">​</a></h3><ul><li>01 背包方案数</li><li>高维前缀和</li></ul><p>一般的，需要满足以下条件：</p><ul><li>计数 DP</li><li>运算可撤销（例如加法、乘法）</li></ul><h3 id="固定顺序" tabindex="-1">固定顺序 <a class="header-anchor" href="#固定顺序" aria-label="Permalink to &quot;固定顺序&quot;">​</a></h3><p>按秩合并并查集。</p><h3 id="常见做法" tabindex="-1">常见做法 <a class="header-anchor" href="#常见做法" aria-label="Permalink to &quot;常见做法&quot;">​</a></h3><ul><li>莫队：一般是任意顺序的，区间查询，不支持修改。</li><li>线段树分治：任意顺序或固定顺序，单点查询，区间修改。</li></ul><h2 id="染色问题" tabindex="-1">染色问题 <a class="header-anchor" href="#染色问题" aria-label="Permalink to &quot;染色问题&quot;">​</a></h2><h3 id="修改" tabindex="-1">修改 <a class="header-anchor" href="#修改" aria-label="Permalink to &quot;修改&quot;">​</a></h3><p>单点修改，区间推平，区间加颜色。</p><h3 id="查询" tabindex="-1">查询 <a class="header-anchor" href="#查询" aria-label="Permalink to &quot;查询&quot;">​</a></h3><p>区间颜色数。</p><h3 id="常见算法" tabindex="-1">常见算法 <a class="header-anchor" href="#常见算法" aria-label="Permalink to &quot;常见算法&quot;">​</a></h3><ul><li>莫队：单点修，区间颜色数。</li><li>线段树维护颜色状压：区间加颜色，区间颜色数。</li><li>线段树维护 <code>pre</code> 数组：单点修，区间颜色数。</li><li>ODT：区间推平，构成颜色段均摊。</li><li>转化成二维数点问题：区间推平，区间颜色数。</li></ul><h2 id="区间-mex-问题" tabindex="-1">区间 mex 问题 <a class="header-anchor" href="#区间-mex-问题" aria-label="Permalink to &quot;区间 mex 问题&quot;">​</a></h2><h3 id="区间扩展和收缩" tabindex="-1">区间扩展和收缩 <a class="header-anchor" href="#区间扩展和收缩" aria-label="Permalink to &quot;区间扩展和收缩&quot;">​</a></h3><p>结合桶，维护没有出现过的数，每次最小的就是 mex。</p><h3 id="区间在线求-mex" tabindex="-1">区间在线求 mex <a class="header-anchor" href="#区间在线求-mex" aria-label="Permalink to &quot;区间在线求 mex&quot;">​</a></h3><ul><li>维护 $n\\times n$ 的矩阵，$t[i][j]$ 表示在 $a[1\\sim i]$ 中，数 $j$ 最后一次出现的位置。</li><li>一个数 $x$ 在 $[l,r]$ 中出现等价于 $a[r][x]\\geq l$。</li><li>想办法维护这个矩阵即可。</li><li>具体做法： <ul><li>在线：可持久化线段树上二分。</li><li>离线：扫描线 + 线段树上二分。</li></ul></li></ul><h2 id="根号分治" tabindex="-1">根号分治 <a class="header-anchor" href="#根号分治" aria-label="Permalink to &quot;根号分治&quot;">​</a></h2><h3 id="发现条件" tabindex="-1">发现条件 <a class="header-anchor" href="#发现条件" aria-label="Permalink to &quot;发现条件&quot;">​</a></h3><p>反的单调性。</p><h3 id="常见形式" tabindex="-1">常见形式 <a class="header-anchor" href="#常见形式" aria-label="Permalink to &quot;常见形式&quot;">​</a></h3><h4 id="分式形式" tabindex="-1">分式形式 <a class="header-anchor" href="#分式形式" aria-label="Permalink to &quot;分式形式&quot;">​</a></h4><ul><li>条件：分子一定。</li><li>分式值和分母做平衡。</li></ul><h4 id="和一定形式" tabindex="-1">和一定形式 <a class="header-anchor" href="#和一定形式" aria-label="Permalink to &quot;和一定形式&quot;">​</a></h4><ul><li>具体的，有：度数和点数，连通块数和块的大小等。</li><li>结论一：数的大小和数量做平衡。</li><li>结论二：数的种类是根号级别的。这其实基于结论一： <ul><li>小数就是有根号种（可能有重复的）。</li><li>大数就是根号个（有重复也没关系）。</li></ul></li></ul><h2 id="线段树合并" tabindex="-1">线段树合并 <a class="header-anchor" href="#线段树合并" aria-label="Permalink to &quot;线段树合并&quot;">​</a></h2><h3 id="处理" tabindex="-1">处理 <a class="header-anchor" href="#处理" aria-label="Permalink to &quot;处理&quot;">​</a></h3><p>与普通的动态开点线段树相同，支持懒标记下传，其特殊的是：当 <code>ls</code> 和 <code>rs</code> 有一个不为空时就下传，否则不下传。</p><h3 id="复杂度" tabindex="-1">复杂度 <a class="header-anchor" href="#复杂度" aria-label="Permalink to &quot;复杂度&quot;">​</a></h3><p>修改时遍历的节点数级别。</p><h4 id="proof" tabindex="-1">proof <a class="header-anchor" href="#proof" aria-label="Permalink to &quot;proof&quot;">​</a></h4><ul><li>首先，懒标记下传产生的新节点数和修改时遍历节点数、合并时遍历节点数同阶，可以不管。</li><li>考虑在所有线段树中同一个节点的所有修改操作次数 $x$。</li><li>假如没有额外的分裂，那么该节点在 <code>merge</code> 函数中被遍历不 <code>return</code> 的次数就是 $x - 1$。</li><li>那么，整个树的 <code>merge</code> 调用次数就是和修改操作遍历节点个数同级。</li></ul><h2 id="启发式" tabindex="-1">启发式 <a class="header-anchor" href="#启发式" aria-label="Permalink to &quot;启发式&quot;">​</a></h2><h3 id="核心" tabindex="-1">核心 <a class="header-anchor" href="#核心" aria-label="Permalink to &quot;核心&quot;">​</a></h3><p>在和一定的情况下，只遍历较小的那个集合。</p><h3 id="注意" tabindex="-1">注意 <a class="header-anchor" href="#注意" aria-label="Permalink to &quot;注意&quot;">​</a></h3><ul><li>关注根据什么来做启发式，不是所有时候都是节点个数。例如，在既要遍历子树，又要遍历子树中的询问的时候，就认为集合大小是节点数 + 询问数。</li><li>关注启发式做法的常数，只要想卡，是容易卡到对数的。</li></ul><h3 id="启发式合并" tabindex="-1">启发式合并 <a class="header-anchor" href="#启发式合并" aria-label="Permalink to &quot;启发式合并&quot;">​</a></h3><ul><li>实现：将小集合中的元素逐个插入到大集合中。</li><li>适用范围： <ul><li>插入复杂度（实现难度）低于合并。</li><li>集合总量可以接受。</li></ul></li><li>常见运用：<code>set</code> 合并。</li></ul><h3 id="启发式分裂" tabindex="-1">启发式分裂 <a class="header-anchor" href="#启发式分裂" aria-label="Permalink to &quot;启发式分裂&quot;">​</a></h3><ul><li>实现：通过同步扫描，不断裂出已经扫完的部分。</li><li>适用范围：自己看着办。</li></ul><h2 id="点分治的实现问题" tabindex="-1">点分治的实现问题 <a class="header-anchor" href="#点分治的实现问题" aria-label="Permalink to &quot;点分治的实现问题&quot;">​</a></h2><h3 id="点分治类型" tabindex="-1">点分治类型 <a class="header-anchor" href="#点分治类型" aria-label="Permalink to &quot;点分治类型&quot;">​</a></h3><p>点分治有两种，一种是计数，一种是最优化。</p><h3 id="计数类方便实现方法" tabindex="-1">计数类方便实现方法 <a class="header-anchor" href="#计数类方便实现方法" aria-label="Permalink to &quot;计数类方便实现方法&quot;">​</a></h3><ul><li><code>ans += solve(rt);</code> // 直接统计当前分治树的点对贡献</li><li><code>ans -= solve(son);</code> // 容斥掉 <code>rt</code> 的各个子树的不合法部分</li></ul><p>而对于 <code>solve(x)</code> 函数，通常可以把所有点都放进一个序列里，然后直接用某些离线做法。这样可以避免用一些在线数据结构，代码更好写，复杂度也更优。注意，这种做法不用考虑从 <code>rt</code> 出发的某些特殊情况。</p><h3 id="通用实现方法" tabindex="-1">通用实现方法 <a class="header-anchor" href="#通用实现方法" aria-label="Permalink to &quot;通用实现方法&quot;">​</a></h3><ul><li>涉及最值的，可以优先考虑法二。</li></ul><h4 id="法一" tabindex="-1">法一 <a class="header-anchor" href="#法一" aria-label="Permalink to &quot;法一&quot;">​</a></h4><ul><li>利用某些在线数据结构，先把所有点都加进去；当要统计某棵子树的贡献时，就再把其贡献删掉，统计完再加回来。</li><li>但是，在某些最优化中，我们可以不用又删又加的，可以直接维护最大次大值，本质和换根 DP 相似。</li><li>注意，这种做法必须考虑从 <code>rt</code> 出发的某些特殊情况。</li></ul><h4 id="法二" tabindex="-1">法二 <a class="header-anchor" href="#法二" aria-label="Permalink to &quot;法二&quot;">​</a></h4><ul><li>考虑正着扫的同时加入一棵棵子树的贡献，然后再清空，再倒着做一遍。</li><li>通常用于处理删除操作不好实现的情况。</li><li>如果路径无序，则不需要再倒着做一遍。</li></ul><h3 id="点分治卡常的常见办法" tabindex="-1">点分治卡常的常见办法 <a class="header-anchor" href="#点分治卡常的常见办法" aria-label="Permalink to &quot;点分治卡常的常见办法&quot;">​</a></h3><ul><li>多次调用，先建出点分树。</li><li>灵活选用上述的各种写法（一定要在 coding 之前确定当前做法最简）。</li></ul><h2 id="树上对链或连通块的查询问题处理" tabindex="-1">树上对链或连通块的查询问题处理 <a class="header-anchor" href="#树上对链或连通块的查询问题处理" aria-label="Permalink to &quot;树上对链或连通块的查询问题处理&quot;">​</a></h2><h3 id="类型" tabindex="-1">类型 <a class="header-anchor" href="#类型" aria-label="Permalink to &quot;类型&quot;">​</a></h3><ul><li>求最优的连通块</li><li>求最优的链</li><li>查询某条链对应的信息</li><li>查询某个连通块对应的信息（一般带修）</li></ul><h3 id="带修" tabindex="-1">带修 <a class="header-anchor" href="#带修" aria-label="Permalink to &quot;带修&quot;">​</a></h3><ul><li>树链剖分：处理查询问题。</li><li>cdq：处理查询和最优化问题。</li></ul><h3 id="不修" tabindex="-1">不修 <a class="header-anchor" href="#不修" aria-label="Permalink to &quot;不修&quot;">​</a></h3><ul><li>比较通用的做法： <ul><li>树链剖分：处理查询问题。</li><li>点分治：可以处理查询和最优化问题。</li><li>换根：处理对于每个起点的链查询，可以结合 DP 或 dfs 序。</li></ul></li><li>如果使用了点分治，可能可以有如下进阶办法： <ul><li>直接在 lca 处处理对应的链： <ul><li>核心难点：处理链的合并。</li><li>常用相关算法： <ul><li>dsu on tree</li><li>线段树合并</li></ul></li></ul></li></ul></li></ul><h2 id="可持久化数据结构" tabindex="-1">可持久化数据结构 <a class="header-anchor" href="#可持久化数据结构" aria-label="Permalink to &quot;可持久化数据结构&quot;">​</a></h2><h3 id="处理办法" tabindex="-1">处理办法 <a class="header-anchor" href="#处理办法" aria-label="Permalink to &quot;处理办法&quot;">​</a></h3><p>将改变了的节点新建出来，作为新的版本。这样的时空做法复杂度就是和修改的节点数相同的。</p><h3 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论" aria-label="Permalink to &quot;结论&quot;">​</a></h3><p>基于均摊/势能分析的做法可持久化的复杂度是：单次操作降到其最劣修改复杂度。</p><h4 id="proof-1" tabindex="-1">proof <a class="header-anchor" href="#proof-1" aria-label="Permalink to &quot;proof&quot;">​</a></h4><p>只要每次做最劣修改然后再回退即可。</p><h3 id="常见例子" tabindex="-1">常见例子 <a class="header-anchor" href="#常见例子" aria-label="Permalink to &quot;常见例子&quot;">​</a></h3><ul><li>路径压缩的并查集</li><li>splay</li></ul>',89),h=[o];function t(d,n,u,c,s,q){return l(),e("div",null,h)}const f=a(r,[["render",t]]);export{m as __pageData,f as default};
