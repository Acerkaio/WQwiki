import{_ as $,o as a,c as e,Q as t}from"./chunks/framework.e7363dcb.js";const _=JSON.parse('{"title":"网络流建模","description":"","frontmatter":{},"headers":[],"relativePath":"Mad/网络流/网络流建模.md","filePath":"Mad/网络流/网络流建模.md","lastUpdated":1738666900000}'),i={name:"Mad/网络流/网络流建模.md"},r=t('<h1 id="网络流建模" tabindex="-1">网络流建模 <a class="header-anchor" href="#网络流建模" aria-label="Permalink to &quot;网络流建模&quot;">​</a></h1><h2 id="二分图最大匹配" tabindex="-1">二分图最大匹配 <a class="header-anchor" href="#二分图最大匹配" aria-label="Permalink to &quot;二分图最大匹配&quot;">​</a></h2><h3 id="内容" tabindex="-1">内容 <a class="header-anchor" href="#内容" aria-label="Permalink to &quot;内容&quot;">​</a></h3><p>将边分成匹配和非匹配边，使每个点相邻的匹配边数量 $\\leq 1$。</p><h3 id="思路" tabindex="-1">思路 <a class="header-anchor" href="#思路" aria-label="Permalink to &quot;思路&quot;">​</a></h3><p>考虑刻画限制数量 $\\leq 1$，而最大流是容易刻画数量限制的。利用二分图，分别对左右部点进行处理即可。</p><p>即对于二分图 $G=(V = L\\cup R, E)$，其中 $L$ 和 $R$ 为左右部点集，可构建源点 $s$ 和汇点 $t$，从 $s$ 向 $L$ 中每个点连容量为 $1$ 的边，从 $R$ 中每个点向 $t$ 连容量为 $1$ 的边，原图中的边容量设为 $1$。通过求 $s$ 到 $t$ 的最大流，可得到二分图的最大匹配。</p><p>当然，也可以认为这要转化成刻画选择，可以用最小割，但复杂度更差。</p><h2 id="集合划分问题" tabindex="-1">集合划分问题 <a class="header-anchor" href="#集合划分问题" aria-label="Permalink to &quot;集合划分问题&quot;">​</a></h2><h3 id="内容-1" tabindex="-1">内容 <a class="header-anchor" href="#内容-1" aria-label="Permalink to &quot;内容&quot;">​</a></h3><p>设有 $n$ 个物品，对于每个物品 $i$，选择 $A$ 有代价 $a_i$，选择 $B$ 有代价 $b_i$，对于某些物品对 $(i, j)$，若 $i$ 和 $j$ 不在同一集合，有额外代价 $c_{ij}$，求总代价最小的划分方案。</p><h3 id="思路-1" tabindex="-1">思路 <a class="header-anchor" href="#思路-1" aria-label="Permalink to &quot;思路&quot;">​</a></h3><p>涉及到集合划分的，常见做法是最小割，因为最小割容易刻画“选择”。</p><p>套路的考虑让割边表示选择，构建源点 $s$ 和汇点 $t$。对于每个物品 $i$，从 $s$ 向 $i$ 连容量为 $a_i$ 的边，从 $i$ 向 $t$ 连容量为 $b_i$ 的边。对于存在代价 $c_{ij}$ 的物品对 $(i, j)$，在 $i$ 和 $j$ 之间连双向边，容量为 $c_{ij}$。通过求 $s$ 到 $t$ 的最小割，可得到最小总代价。</p><h2 id="二分图最小点覆盖" tabindex="-1">二分图最小点覆盖 <a class="header-anchor" href="#二分图最小点覆盖" aria-label="Permalink to &quot;二分图最小点覆盖&quot;">​</a></h2><h3 id="内容-2" tabindex="-1">内容 <a class="header-anchor" href="#内容-2" aria-label="Permalink to &quot;内容&quot;">​</a></h3><p>对于二分图 $G=(V = L\\cup R, E)$，选出一个大小最小的点集 $S \\subseteq V$，使得 $\\forall (u, v) \\in E$，都有 $u \\in S$ 或 $v \\in S$。</p><h3 id="思路-2" tabindex="-1">思路 <a class="header-anchor" href="#思路-2" aria-label="Permalink to &quot;思路&quot;">​</a></h3><p>刻画选择，所以考虑最小割。</p><p>考虑什么时候不合法，就是一条边两个端点都不选。</p><p>构建源点 $s$ 和汇点 $t$，从 $s$ 向 $L$ 中每个点连容量为 $1$ 的边，从 $R$ 中每个点向 $t$ 连容量为 $1$ 的边。对于原图中的每条边 $(u, v)$，其中 $u \\in L$，$v \\in R$，从 $u$ 向 $v$ 连容量为 $+\\infty$ 的边。通过求 $s$ 到 $t$ 的最小割，割边所关联的点集即为最小点覆盖集。</p><h2 id="二分图最大独立集" tabindex="-1">二分图最大独立集 <a class="header-anchor" href="#二分图最大独立集" aria-label="Permalink to &quot;二分图最大独立集&quot;">​</a></h2><p>和最小点覆盖是补问题。即对于二分图 $G=(V, E)$，设最小点覆盖集为 $S$，则最大独立集为 $V - S$。</p><h2 id="最大权闭合子图" tabindex="-1">最大权闭合子图 <a class="header-anchor" href="#最大权闭合子图" aria-label="Permalink to &quot;最大权闭合子图&quot;">​</a></h2><h3 id="内容-3" tabindex="-1">内容 <a class="header-anchor" href="#内容-3" aria-label="Permalink to &quot;内容&quot;">​</a></h3><p>给定有向图 $G=(V, E)$，每个点 $v$ 有一个权值 $w(v)$，求一个子图 $G&#39;=(V&#39;, E&#39;)$，其中 $V&#39; \\subseteq V$，$E&#39; \\subseteq E$，且对于任意 $(u, v) \\in E$，若 $u \\in V&#39;$，则 $v \\in V&#39;$，使得 $\\sum_{v \\in V&#39;} w(v)$ 最大。</p><h3 id="思路-3" tabindex="-1">思路 <a class="header-anchor" href="#思路-3" aria-label="Permalink to &quot;思路&quot;">​</a></h3><p>刻画选择，考虑最小割。</p><p>先把最大转最小，设所有点权和为 $W = \\sum_{v \\in V} w(v)$，我们要最大化的是 $\\sum_{v \\in V&#39;} w(v)$，那么等价于最小化 $W - \\sum_{v \\in V&#39;} w(v)$。</p><p>构建源点 $s$ 和汇点 $t$，对于权值为正的点 $v$，从 $s$ 向 $v$ 连容量为 $w(v)$ 的边；对于权值为负的点 $v$，从 $v$ 向 $t$ 连容量为 $-w(v)$ 的边。原图中的边容量设为 $+\\infty$。通过求 $s$ 到 $t$ 的最小割，$W$ 减去最小割的值即为最大权闭合子图的权值。</p><h2 id="最小dag路径覆盖" tabindex="-1">最小DAG路径覆盖 <a class="header-anchor" href="#最小dag路径覆盖" aria-label="Permalink to &quot;最小DAG路径覆盖&quot;">​</a></h2><h3 id="不相交" tabindex="-1">不相交 <a class="header-anchor" href="#不相交" aria-label="Permalink to &quot;不相交&quot;">​</a></h3><p>每个点恰被一条路径覆盖，求所需的最小路径数量。</p><h4 id="思路-4" tabindex="-1">思路 <a class="header-anchor" href="#思路-4" aria-label="Permalink to &quot;思路&quot;">​</a></h4><p>限制难处理，考虑重新刻画。</p><p>点没前途，考虑边，发现限制就是每个点的入边选择数量 $\\leq 1$ 且出边选择数量 $\\leq 1$，然后要让选的边最多。</p><p>具体做法是将每个点 $v$ 拆成 $v_{in}$ 和 $v_{out}$，从 $s$ 向每个 $v_{in}$ 连容量为 $1$ 的边，从每个 $v_{out}$ 向 $t$ 连容量为 $1$ 的边。对于原图中的边 $(u, v)$，从 $u_{out}$ 向 $v_{in}$ 连容量为 $1$ 的边。通过求 $s$ 到 $t$ 的最大流 $f$，最小路径覆盖数为 $|V| - f$。</p><p>当然，直接做也可以，用最小费用最大流可以实现相同复杂度。</p><h3 id="可相交" tabindex="-1">可相交 <a class="header-anchor" href="#可相交" aria-label="Permalink to &quot;可相交&quot;">​</a></h3><p>将“恰”改为“至少”。</p><h4 id="思路-5" tabindex="-1">思路 <a class="header-anchor" href="#思路-5" aria-label="Permalink to &quot;思路&quot;">​</a></h4><p>考虑刻画之，但没什么想法，尝试直接做。</p><p>DP不行，看网络流，这其实是有下界的最小流。</p><p>直接用上下界最小费用可行流即可。</p><p>当然，也可以考虑重新刻画路径的本质。</p><p>将所有点划分成若干集合，限制是集合内部的点满足相邻可达。</p><p>那我们只关心可达性，对原图进行传递闭包，设得到的图为 $G&#39;=(V, E&#39;)$，然后在 $G&#39;$ 上用不相交路径覆盖的方法求解。</p><h2 id="切糕问题" tabindex="-1">切糕问题 <a class="header-anchor" href="#切糕问题" aria-label="Permalink to &quot;切糕问题&quot;">​</a></h2><h3 id="内容-4" tabindex="-1">内容 <a class="header-anchor" href="#内容-4" aria-label="Permalink to &quot;内容&quot;">​</a></h3><p>来自HNOI2013。</p><h3 id="思路-6" tabindex="-1">思路 <a class="header-anchor" href="#思路-6" aria-label="Permalink to &quot;思路&quot;">​</a></h3><p>考虑直接做，dp几乎不可能，考虑用割刻画选择。</p><p>设有一个 $n \\times m$ 的网格，每个网格点 $(i, j)$ 有 $1$ 到 $p$ 种取值，每种取值有不同的代价，同时存在一些限制条件，要求在满足限制条件下，选择一种取值方案使得总代价最小。</p><p>将待选的值 $[1, p]$ 顺次连成一条链，即对于每个网格点 $(i, j)$，从取值为 $k$ 的节点向取值为 $k + 1$ 的节点连容量为对应代价的边（$1 \\leq k &lt; p$）。对于不合法限制，通过连边刻画，例如如果限制 $(i_1, j_1)$ 和 $(i_2, j_2)$ 取值差不能超过某个值，可在相应取值节点间连容量为 $+\\infty$ 的边。通过求最小割，可得到最小总代价。</p>',54),h=[r];function o(l,n,s,d,p,u){return a(),e("div",null,h)}const q=$(i,[["render",o]]);export{_ as __pageData,q as default};
