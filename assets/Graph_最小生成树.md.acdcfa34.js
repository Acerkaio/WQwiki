import{_ as a,o as r,c as e,Q as o}from"./chunks/framework.e7363dcb.js";const b=JSON.parse('{"title":"最小生成树","description":"","frontmatter":{},"headers":[],"relativePath":"Graph/最小生成树.md","filePath":"Graph/最小生成树.md","lastUpdated":1740448168000}'),l={name:"Graph/最小生成树.md"},i=o('<h1 id="最小生成树" tabindex="-1">最小生成树 <a class="header-anchor" href="#最小生成树" aria-label="Permalink to &quot;最小生成树&quot;">​</a></h1><h2 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h2><h3 id="定义1" tabindex="-1">定义1 <a class="header-anchor" href="#定义1" aria-label="Permalink to &quot;定义1&quot;">​</a></h3><p>给定一张带权连通图，求其边权和最小的生成树，称为最小生成树。</p><h3 id="定义2" tabindex="-1">定义2 <a class="header-anchor" href="#定义2" aria-label="Permalink to &quot;定义2&quot;">​</a></h3><p>给定一张带权连通图，求其的生成树，称为最小生成树。</p><p>以上定义等价，证明结合kruskal的算法流程证明即可。</p><h2 id="性质-以下性质都是充要的" tabindex="-1">性质（以下性质都是充要的） <a class="header-anchor" href="#性质-以下性质都是充要的" aria-label="Permalink to &quot;性质（以下性质都是充要的）&quot;">​</a></h2><h3 id="性质1" tabindex="-1">性质1 <a class="header-anchor" href="#性质1" aria-label="Permalink to &quot;性质1&quot;">​</a></h3><p>原图中任何一个环，其环上权值严格最大的边必然不在最小生成树上。</p><h4 id="proof" tabindex="-1">proof <a class="header-anchor" href="#proof" aria-label="Permalink to &quot;proof&quot;">​</a></h4><p>假如在树上，将此边删去，则原树变成两个连通块 $T_1$、$T_2$。经过该环的另一边，可以从 $T_1$ 到 $T_2$，必然有一条边连接 $T_1$ 和 $T_2$，替换更优。这个性质是最小生成树的核心性质。</p><h3 id="性质2" tabindex="-1">性质2 <a class="header-anchor" href="#性质2" aria-label="Permalink to &quot;性质2&quot;">​</a></h3><p>任何一条非树边对应的树上路径的最大权小于等于该非树边。</p><h4 id="proof-1" tabindex="-1">proof <a class="header-anchor" href="#proof-1" aria-label="Permalink to &quot;proof&quot;">​</a></h4><p>由性质1反证即可。</p><h3 id="性质3" tabindex="-1">性质3 <a class="header-anchor" href="#性质3" aria-label="Permalink to &quot;性质3&quot;">​</a></h3><p>原图中 $x$、$y$ 之间的任何一条（简单）路径的最大权，必然大于 $x$、$y$ 树上路径的最大权。</p><h4 id="proof-2" tabindex="-1">proof <a class="header-anchor" href="#proof-2" aria-label="Permalink to &quot;proof&quot;">​</a></h4><p>原图路径每次经过非树边都可以被调整成树边路径。如果出现了非简单路径，可以将重复部分去掉（也可以不去掉）。</p><h3 id="性质4" tabindex="-1">性质4 <a class="header-anchor" href="#性质4" aria-label="Permalink to &quot;性质4&quot;">​</a></h3><p>最小生成树最大树边边权最小。</p><h4 id="proof-3" tabindex="-1">proof <a class="header-anchor" href="#proof-3" aria-label="Permalink to &quot;proof&quot;">​</a></h4><p>连续段dp，利用性质2，不管怎样调整都不会更优了。</p><h2 id="求解算法" tabindex="-1">求解算法 <a class="header-anchor" href="#求解算法" aria-label="Permalink to &quot;求解算法&quot;">​</a></h2><p>正确性都是利用性质1的充要性：任何一条边加入时，假如某个环中它是最大边，则环中其他边都已经考虑过了。</p><h3 id="kruskal" tabindex="-1">kruskal <a class="header-anchor" href="#kruskal" aria-label="Permalink to &quot;kruskal&quot;">​</a></h3><p>流程：按边权从小到大考虑边能否取进生成树。</p><h3 id="prim" tabindex="-1">prim <a class="header-anchor" href="#prim" aria-label="Permalink to &quot;prim&quot;">​</a></h3><p>流程：类似dij，本质上是实时维护了一个连通块出去的所有边，每次取最小的一条边加入生成树。 实现：有类似dij的 $O((m + n)\\log m)$，也有应对完全图的 $O(n^2)$。</p><h3 id="boruvka" tabindex="-1">boruvka <a class="header-anchor" href="#boruvka" aria-label="Permalink to &quot;boruvka&quot;">​</a></h3><h4 id="流程" tabindex="-1">流程 <a class="header-anchor" href="#流程" aria-label="Permalink to &quot;流程&quot;">​</a></h4><p>每次取当前连通块的最小非块内边放入边集 $E$。对 $E$ 按边权排序，当边两端点不在同一块内，就将当前边加入生成树，并合并两连通块。</p><h4 id="得到最小非块内边的常见处理" tabindex="-1">得到最小非块内边的常见处理 <a class="header-anchor" href="#得到最小非块内边的常见处理" aria-label="Permalink to &quot;得到最小非块内边的常见处理&quot;">​</a></h4><ul><li>直接实现：想办法跳过当前块内点，例如只考虑点与点之间的间隙点。</li><li>差分实现：预处理出总点集，然后每次遍历到当前连通块就先暴力减去块内的，然后求解，处理完恢复。</li></ul><h2 id="完全图最小生成树" tabindex="-1">完全图最小生成树 <a class="header-anchor" href="#完全图最小生成树" aria-label="Permalink to &quot;完全图最小生成树&quot;">​</a></h2><h3 id="形式" tabindex="-1">形式 <a class="header-anchor" href="#形式" aria-label="Permalink to &quot;形式&quot;">​</a></h3><p>图的边数非常多，求最小生成树。</p><h3 id="常见处理办法" tabindex="-1">常见处理办法 <a class="header-anchor" href="#常见处理办法" aria-label="Permalink to &quot;常见处理办法&quot;">​</a></h3><h4 id="boruvka-1" tabindex="-1">boruvka <a class="header-anchor" href="#boruvka-1" aria-label="Permalink to &quot;boruvka&quot;">​</a></h4><p>比较暴力的办法，容易结合DS实现，但复杂度可能多一个 $\\log$。</p><h4 id="模拟kruskal" tabindex="-1">模拟kruskal <a class="header-anchor" href="#模拟kruskal" aria-label="Permalink to &quot;模拟kruskal&quot;">​</a></h4><p>核心是通过对kruskal流程的分析，结合性质1，从而：</p><ul><li>得到一定不优的边，降低边数。</li><li>想办法实现kruskal的过程。</li></ul><h4 id="模拟prim" tabindex="-1">模拟prim <a class="header-anchor" href="#模拟prim" aria-label="Permalink to &quot;模拟prim&quot;">​</a></h4><p>核心有两种考虑办法：</p><ul><li>法一：考虑从当前块出发的最小的边，类似boruvka的考虑办法。</li><li>法二：利用新扩展的点去松弛各个没有扩展的点，类似dij的考虑办法（常见）。</li></ul><h3 id="传奇例题-xor-mst" tabindex="-1">传奇例题：XOR - MST <a class="header-anchor" href="#传奇例题-xor-mst" aria-label="Permalink to &quot;传奇例题：XOR - MST&quot;">​</a></h3><h4 id="solution1-boruvka" tabindex="-1">solution1: boruvka <a class="header-anchor" href="#solution1-boruvka" aria-label="Permalink to &quot;solution1: boruvka&quot;">​</a></h4><p>利用预处理全局点值trie，每次差分得到块外点值trie，然后就是最大xor点对。</p><h4 id="solution2-模拟kruskal" tabindex="-1">solution2: 模拟kruskal <a class="header-anchor" href="#solution2-模拟kruskal" aria-label="Permalink to &quot;solution2: 模拟kruskal&quot;">​</a></h4><p>trie树上刻画边权大小，假如当前考虑到前 $k$ 位都是0的边（$k$ 从大到小），那么边必然在深度为 $k$ 的节点的左右子树之间，直接连复杂度会退化。考虑每次只取从每个点出发最小的边，因为次大的一定不优。将这些边按大小排序，跑kruskal即可。复杂度 $O(n\\times\\log V\\times\\log n)$。</p><h4 id="solution3-模拟prim" tabindex="-1">solution3：模拟prim <a class="header-anchor" href="#solution3-模拟prim" aria-label="Permalink to &quot;solution3：模拟prim&quot;">​</a></h4><p>此题好像没办法用，尽力了。</p><h2 id="瓶颈路问题-性质4的扩展" tabindex="-1">瓶颈路问题（性质4的扩展） <a class="header-anchor" href="#瓶颈路问题-性质4的扩展" aria-label="Permalink to &quot;瓶颈路问题（性质4的扩展）&quot;">​</a></h2><h3 id="经验性事实" tabindex="-1">经验性事实 <a class="header-anchor" href="#经验性事实" aria-label="Permalink to &quot;经验性事实&quot;">​</a></h3><p>当你在二分答案的check部分使用了并查集时，很有可能可以用最小生成树。</p><h3 id="kruskal构建的特殊最小生成树" tabindex="-1">kruskal构建的特殊最小生成树 <a class="header-anchor" href="#kruskal构建的特殊最小生成树" aria-label="Permalink to &quot;kruskal构建的特殊最小生成树&quot;">​</a></h3><h4 id="按秩合并实现的并查集恰好对应了一棵最小生成树" tabindex="-1">按秩合并实现的并查集恰好对应了一棵最小生成树 <a class="header-anchor" href="#按秩合并实现的并查集恰好对应了一棵最小生成树" aria-label="Permalink to &quot;按秩合并实现的并查集恰好对应了一棵最小生成树&quot;">​</a></h4><h4 id="性质" tabindex="-1">性质 <a class="header-anchor" href="#性质" aria-label="Permalink to &quot;性质&quot;">​</a></h4><ul><li>树高是 $\\log$ 的，可以支持各种暴力。</li><li>两点的瓶颈一定路径上lca的左边或右边的边。</li></ul><h4 id="最大的优点" tabindex="-1">最大的优点 <a class="header-anchor" href="#最大的优点" aria-label="Permalink to &quot;最大的优点&quot;">​</a></h4><p>写起来特别方便，常数特别小。</p><h3 id="kruskal重构树" tabindex="-1">kruskal重构树 <a class="header-anchor" href="#kruskal重构树" aria-label="Permalink to &quot;kruskal重构树&quot;">​</a></h3><h4 id="流程-1" tabindex="-1">流程 <a class="header-anchor" href="#流程-1" aria-label="Permalink to &quot;流程&quot;">​</a></h4><p>每一条生成树上的边对应重构树上一个非叶点，叶子都是原节点。每次并查集合并时，给当前边新建一个点，赋点权为当前边权，然后儿子是合并的集合的代表，然后将当前节点作为被合并的集合的代表。</p><h4 id="性质-1" tabindex="-1">性质 <a class="header-anchor" href="#性质-1" aria-label="Permalink to &quot;性质&quot;">​</a></h4><ul><li>重构树是大根堆，二叉树。</li><li>两点路径的瓶颈路的瓶颈是其lca点权。</li><li>求一个点在瓶颈 $\\leq lim$ 的情况下能到的点，就是可以其满足点权 $\\leq lim$ 最浅祖先对应子树中的点。</li></ul><h4 id="最大的优点-1" tabindex="-1">最大的优点 <a class="header-anchor" href="#最大的优点-1" aria-label="Permalink to &quot;最大的优点&quot;">​</a></h4><p>性质丰富。</p><h3 id="点权多叉重构树" tabindex="-1">点权多叉重构树 <a class="header-anchor" href="#点权多叉重构树" aria-label="Permalink to &quot;点权多叉重构树&quot;">​</a></h3><h4 id="处理点权瓶颈路" tabindex="-1">处理点权瓶颈路 <a class="header-anchor" href="#处理点权瓶颈路" aria-label="Permalink to &quot;处理点权瓶颈路&quot;">​</a></h4><h4 id="流程-2" tabindex="-1">流程 <a class="header-anchor" href="#流程-2" aria-label="Permalink to &quot;流程&quot;">​</a></h4><p>将边换成点考虑kruskal（本质上是模拟kruskal）。将点按权从小到大排序，假设当前到了 $x$，权 $w[x]$。枚举出边 $(x, y)$，只考虑 $w[x]\\geq w[y]$ 的，然后将能连的连起来，同时 $x$ 是他们的父亲。</p><h2 id="次小生成树" tabindex="-1">次小生成树 <a class="header-anchor" href="#次小生成树" aria-label="Permalink to &quot;次小生成树&quot;">​</a></h2><p>根据性质1，次小生成树必然是由一条非树边替换其对应路径上的最大边形成的。</p>',76),h=[i];function t(n,u,s,d,k,c){return r(),e("div",null,h)}const q=a(l,[["render",t]]);export{b as __pageData,q as default};
