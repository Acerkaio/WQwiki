import{_ as a,o as e,c as i,Q as l}from"./chunks/framework.e7363dcb.js";const q=JSON.parse('{"title":"最短路相关","description":"","frontmatter":{},"headers":[],"relativePath":"Graph/最短路相关.md","filePath":"Graph/最短路相关.md","lastUpdated":1740448168000}'),r={name:"Graph/最短路相关.md"},o=l('<h1 id="最短路相关" tabindex="-1">最短路相关 <a class="header-anchor" href="#最短路相关" aria-label="Permalink to &quot;最短路相关&quot;">​</a></h1><h2 id="floyd" tabindex="-1">floyd <a class="header-anchor" href="#floyd" aria-label="Permalink to &quot;floyd&quot;">​</a></h2><h3 id="适用范围" tabindex="-1">适用范围 <a class="header-anchor" href="#适用范围" aria-label="Permalink to &quot;适用范围&quot;">​</a></h3><p>稠密图全源最短路。</p><h3 id="算法原理" tabindex="-1">算法原理 <a class="header-anchor" href="#算法原理" aria-label="Permalink to &quot;算法原理&quot;">​</a></h3><p>常见的 floyd 是实时维护一个点集 $V$，当前 $dis[i][j]$ 表示从 $i$ 到 $j$ 只能中途经过 $V$ 中点的最短路。注意，这里的“中途”不含起点和终点（这是因为 朴素的 floyd 初始 $f[i][j]$ 表示邻接矩阵）。当然，可以改成每次路径全程不经过某些点，这只需要特判起点和终点即可。</p><h3 id="正确性证明" tabindex="-1">正确性证明 <a class="header-anchor" href="#正确性证明" aria-label="Permalink to &quot;正确性证明&quot;">​</a></h3><p>每次新增一个点，$i,j$ 之间的最短路要么经过，要么不经过。</p><ul><li>不经过就是原来的 $dis$。</li><li>经过的话，如果图没有负环，必然经过恰一次，就是 $dis[i][k]+dis[k][j]$。 注意这里是滚动实现，因为没有负环时，经过同一个点两次必然不优。</li></ul><h3 id="判负环" tabindex="-1">判负环 <a class="header-anchor" href="#判负环" aria-label="Permalink to &quot;判负环&quot;">​</a></h3><p>必然有一个点经过了两次，做两次 floyd，在第二次看能不能再松弛即可。</p><h3 id="扩展" tabindex="-1">扩展 <a class="header-anchor" href="#扩展" aria-label="Permalink to &quot;扩展&quot;">​</a></h3><p>结合线段树分治实现稠密图加点删点全源最短路（边的问题类似）。</p><h2 id="dijkstra" tabindex="-1">dijkstra <a class="header-anchor" href="#dijkstra" aria-label="Permalink to &quot;dijkstra&quot;">​</a></h2><h3 id="适用范围-1" tabindex="-1">适用范围 <a class="header-anchor" href="#适用范围-1" aria-label="Permalink to &quot;适用范围&quot;">​</a></h3><p>非负权单源最短路。</p><h3 id="原理" tabindex="-1">原理 <a class="header-anchor" href="#原理" aria-label="Permalink to &quot;原理&quot;">​</a></h3><p>简单贪心，略。</p><h3 id="扩展-模拟-dij" tabindex="-1">扩展：模拟 dij <a class="header-anchor" href="#扩展-模拟-dij" aria-label="Permalink to &quot;扩展：模拟 dij&quot;">​</a></h3><p>dij 的过程非常简单，核心就两步：</p><ul><li>找到最小点。</li><li>用当前点松弛所有相连点。</li></ul><p>模拟的难点在于松弛部分，通常可以用 DS 实现。经典的：处理区间连边。</p><h2 id="bellman-ford" tabindex="-1">bellman - ford <a class="header-anchor" href="#bellman-ford" aria-label="Permalink to &quot;bellman - ford&quot;">​</a></h2><h3 id="正确性证明-1" tabindex="-1">正确性证明 <a class="header-anchor" href="#正确性证明-1" aria-label="Permalink to &quot;正确性证明&quot;">​</a></h3><p>没有负环的时候，最短路长度 $\\leq n$。</p><h2 id="spfa" tabindex="-1">spfa <a class="header-anchor" href="#spfa" aria-label="Permalink to &quot;spfa&quot;">​</a></h2><h3 id="复杂度证明" tabindex="-1">复杂度证明 <a class="header-anchor" href="#复杂度证明" aria-label="Permalink to &quot;复杂度证明&quot;">​</a></h3><p>每个点入队必然因为某条新边导致的最短路，最多入队 $m$ 次。</p><h3 id="判负环-1" tabindex="-1">判负环 <a class="header-anchor" href="#判负环-1" aria-label="Permalink to &quot;判负环&quot;">​</a></h3><p>建立超级源点，连向每一个点，跑 spfa（保证连通性），同时记录最短路点数，超过 $n$ 就有负环。</p><h3 id="优化" tabindex="-1">优化 <a class="header-anchor" href="#优化" aria-label="Permalink to &quot;优化&quot;">​</a></h3><ul><li>直接优化（正式比赛不要往这方面想）：比较常用的是 SLF 优化。</li><li>去掉负权边跑 dij（常用）： <ul><li>重新设计建图。</li><li>结合图的特性，合理赋势能。</li></ul></li></ul><h2 id="k-bfs" tabindex="-1">k - bfs <a class="header-anchor" href="#k-bfs" aria-label="Permalink to &quot;k - bfs&quot;">​</a></h2><h3 id="适用范围-2" tabindex="-1">适用范围 <a class="header-anchor" href="#适用范围-2" aria-label="Permalink to &quot;适用范围&quot;">​</a></h3><p>边权非负且值域可以接受。</p><h3 id="本质" tabindex="-1">本质 <a class="header-anchor" href="#本质" aria-label="Permalink to &quot;本质&quot;">​</a></h3><p>模拟 dij，通过让每个队列内部不降，保证取到最小值。</p><h3 id="复杂度" tabindex="-1">复杂度 <a class="header-anchor" href="#复杂度" aria-label="Permalink to &quot;复杂度&quot;">​</a></h3><p>$O(nv + m)$，特别的有 01bfs。</p><h2 id="差分约束问题" tabindex="-1">差分约束问题 <a class="header-anchor" href="#差分约束问题" aria-label="Permalink to &quot;差分约束问题&quot;">​</a></h2><ul><li>处理不等关系：直接建边。</li><li>相等关系：建双向边。</li><li>和特殊值的不等关系：取虚点建边。</li></ul><h2 id="johnson" tabindex="-1">johnson <a class="header-anchor" href="#johnson" aria-label="Permalink to &quot;johnson&quot;">​</a></h2><p>利用差分约束实现一般图的赋势能。</p><h2 id="最短路树" tabindex="-1">最短路树 <a class="header-anchor" href="#最短路树" aria-label="Permalink to &quot;最短路树&quot;">​</a></h2><p>以下都是有向任意边权图。</p><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h3><ul><li>最短路 DAG：满足 $dis[v]=dis[u]+w(u,v)$ 的边组成的图。</li><li>最短路树：最短路 DAG 的生成树，注意，这是有向树。</li></ul><h3 id="性质" tabindex="-1">性质 <a class="header-anchor" href="#性质" aria-label="Permalink to &quot;性质&quot;">​</a></h3><ul><li>（核心）非树边满足三角形不等式。</li><li>任何一条从 $st$ 出发到 $ed$ 的简单路径和合法的非树边序列一一对应。合法：序列中的任何非树边前驱能只走树边到该非树边。</li><li>路径权值和非树边序列权值的对应关系： <ul><li>将非树边的权值重定义为 $dis[v]+w(u,v)-dis[u]$。</li><li>路径的长度就是非树边权值和加上 $st,ed$ 之间的最短路长度。</li></ul></li></ul><h2 id="k-短路" tabindex="-1">k 短路 <a class="header-anchor" href="#k-短路" aria-label="Permalink to &quot;k 短路&quot;">​</a></h2><ul><li>不要求简单路径：在 dij 过程中第 $k$ 次取出的 $x$ 点 $dis$ 就是 $k$ 短路。</li><li>简单路径：结合最短路树和调整法实现。</li></ul><h2 id="同余最短路" tabindex="-1">同余最短路 <a class="header-anchor" href="#同余最短路" aria-label="Permalink to &quot;同余最短路&quot;">​</a></h2><h3 id="适用范围-3" tabindex="-1">适用范围 <a class="header-anchor" href="#适用范围-3" aria-label="Permalink to &quot;适用范围&quot;">​</a></h3><p>存在性完全背包问题。</p><h3 id="原理-1" tabindex="-1">原理 <a class="header-anchor" href="#原理-1" aria-label="Permalink to &quot;原理&quot;">​</a></h3><p>任取一个基准物品，记其体积为 $mod$。那么，对于 $0\\leq i\\lt mod$，$dis[i]$ 表示到达 $j\\times mod + i$ 的最小的 $j\\times mod + i$。对于体积为 $v$ 的物品，其松弛形如 $chkmi(dis[(i + v)%mod],dis[i]+v)$。判定一个体积 $v$ 是否可以表示出来，可以直接看 $dis[v%mod]$ 和 $v$ 的大小关系。</p><h3 id="优化思考" tabindex="-1">优化思考 <a class="header-anchor" href="#优化思考" aria-label="Permalink to &quot;优化思考&quot;">​</a></h3><p>直接实现是最短路，但是，这是否可以直接 DP 去掉 $\\log$ 呢？观察松弛进行的条件，假设从 $st$ 开始，持续松弛成功，过程形如环上跳。而这个跳肯定不会一直成功到 $st$（因为一开始就是用 $dis[st]$ 松弛的）。所以，可以枚举 $st$，模拟跳的过程，转两圈，保证每个环上点都松弛到位。核心：不会经过同一个状态。</p><h2 id="删边最短路" tabindex="-1">删边最短路 <a class="header-anchor" href="#删边最短路" aria-label="Permalink to &quot;删边最短路&quot;">​</a></h2><p>处理 无向正权图 的删边后的固定起终点最短路。下面求 1 到 $n$ 的删边最短路，建出两个最短路树做，懒得写了，太少用了。</p><h2 id="次短路的扩展应用-维护多个最值处理限制" tabindex="-1">次短路的扩展应用：维护多个最值处理限制 <a class="header-anchor" href="#次短路的扩展应用-维护多个最值处理限制" aria-label="Permalink to &quot;次短路的扩展应用：维护多个最值处理限制&quot;">​</a></h2><h3 id="适用背景" tabindex="-1">适用背景 <a class="header-anchor" href="#适用背景" aria-label="Permalink to &quot;适用背景&quot;">​</a></h3><p>处理带限制的最短路（DP 转移）。限制可以被刻画成：解的特征值恰不等于给定集合中的任何一个，其中，特征值需要自己设计。</p><h3 id="适用条件" tabindex="-1">适用条件 <a class="header-anchor" href="#适用条件" aria-label="Permalink to &quot;适用条件&quot;">​</a></h3><p>对于同一个点（状态），不合法的边（转移）的数量是可以接受的。</p><h3 id="经典例子" tabindex="-1">经典例子 <a class="header-anchor" href="#经典例子" aria-label="Permalink to &quot;经典例子&quot;">​</a></h3><ul><li>最短路相邻不能经过相同的点。</li><li>最短路源点不同。</li></ul><h3 id="处理办法" tabindex="-1">处理办法 <a class="header-anchor" href="#处理办法" aria-label="Permalink to &quot;处理办法&quot;">​</a></h3><ul><li>维护(最多不合法数量 + 1)个最值，要求最值的特征值两两不同。</li><li>每次松弛（转移），分类讨论： <ul><li>如果最值集合中没有当前特征值：尝试用当前最值替换集合中的最劣解。</li><li>如果最值集合中有当前特征值：直接更新对应最值。</li></ul></li><li>如果是 DP，直接朴素维护或平衡树维护。</li><li>如果是 dij，每个集合中的最值对应一个点，每次松弛最多更新一个点的 $dis$，及时将其放入队列。</li></ul><h3 id="例题" tabindex="-1">例题 <a class="header-anchor" href="#例题" aria-label="Permalink to &quot;例题&quot;">​</a></h3><p>最短路，但是每个点有点权，要求路径的任何一个前缀的点权异或和不为 0。</p><h3 id="solution" tabindex="-1">solution <a class="header-anchor" href="#solution" aria-label="Permalink to &quot;solution&quot;">​</a></h3><p>直接做就可以了，此题当然可以加强，但我懒得。</p>',73),h=[o];function t(d,n,s,u,c,b){return e(),i("div",null,h)}const p=a(r,[["render",t]]);export{q as __pageData,p as default};
