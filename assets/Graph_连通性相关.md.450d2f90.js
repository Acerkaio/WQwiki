import{_ as l,o as i,c as a,Q as r}from"./chunks/framework.e7363dcb.js";const _=JSON.parse('{"title":"连通性相关","description":"","frontmatter":{},"headers":[],"relativePath":"Graph/连通性相关.md","filePath":"Graph/连通性相关.md","lastUpdated":1738592860000}'),o={name:"Graph/连通性相关.md"},t=r('<h1 id="连通性相关" tabindex="-1">连通性相关 <a class="header-anchor" href="#连通性相关" aria-label="Permalink to &quot;连通性相关&quot;">​</a></h1><h2 id="边双基本性质" tabindex="-1">边双基本性质 <a class="header-anchor" href="#边双基本性质" aria-label="Permalink to &quot;边双基本性质&quot;">​</a></h2><ol><li><strong>任意两点之间的所有路径的必经边</strong><ul><li>任意两点之间的所有路径的必经边（所有路径边集的交） = 两点之间任意一条简单路径经过的割边 = 边双缩点树上两点所在点的路径长。</li></ul></li><li><strong>边双连通关系</strong><ul><li>(x,y) 边双连通意味着任何一条边割去后 (x,y) 仍然连通。</li></ul></li><li><strong>点与边的归属</strong><ul><li>任何一个点恰属于一个边双。</li><li>任何一条边要么属于一个边双，要么是割边。</li></ul></li><li><strong>边双缩点树的连通性</strong><ul><li>边双缩点树割去一条边后点的连通性和原图中割去该边的连通性相同。</li></ul></li><li><strong>边双的传递性</strong><ul><li>边双具有传递性，即若 (a,b) 边双连通，(b,c) 边双连通，则 (a,c) 边双连通。</li></ul></li></ol><h2 id="点双基本性质" tabindex="-1">点双基本性质 <a class="header-anchor" href="#点双基本性质" aria-label="Permalink to &quot;点双基本性质&quot;">​</a></h2><ol><li><strong>任意两点之间所有路径的必经点</strong><ul><li>任意两点之间所有路径的必经点（所有路径点集的交） = 圆方树上两点之间路径的原点个数，且不等于两点之间任意一条简单路径上的割点个数。</li></ul></li><li><strong>圆方树的性质</strong><ul><li>圆方树是无根树。</li></ul></li><li><strong>割点的判定</strong><ul><li>一个点是割点，当且仅当该点是两个点双的交，且该点在圆方树上不是叶子节点。</li></ul></li><li><strong>边与方点的关系</strong><ul><li>任何一条边恰属于一个方点（点双）。</li></ul></li><li><strong>圆方树割点后的连通性</strong><ul><li>圆方树割去一个点后点的连通性和原图中割去该点的连通性相同。</li></ul></li><li><strong>点双的传递性与分类</strong><ul><li>点双不具有传递性。</li><li>点双的分类： <ul><li>点数 = 2：特殊情况，一般需要单独考虑。</li><li>点数 &gt; 2：一般情况，重点考虑此类。</li></ul></li></ul></li></ol><h2 id="一些涉及存在性的性质" tabindex="-1">一些涉及存在性的性质 <a class="header-anchor" href="#一些涉及存在性的性质" aria-label="Permalink to &quot;一些涉及存在性的性质&quot;">​</a></h2><h3 id="边双与点双的回路和环性质" tabindex="-1">边双与点双的回路和环性质 <a class="header-anchor" href="#边双与点双的回路和环性质" aria-label="Permalink to &quot;边双与点双的回路和环性质&quot;">​</a></h3><p>下面的点双不考虑点数 = 2 的特殊情况。</p><ul><li>边双中任意两点有回路（不保证点不交，但保证边不交）。</li><li>点双中经过任意两点/任意一点一边/任意两边有简单环。</li></ul><h3 id="menger-定理" tabindex="-1">Menger 定理 <a class="header-anchor" href="#menger-定理" aria-label="Permalink to &quot;Menger 定理&quot;">​</a></h3><ul><li>无向图上任意不同的两点不连通所需删去的边的数量的最小值 = 两点之间边不相交的迹的数量的最大值。</li><li>无向图上任意不同且不相邻的两点不连通所需删去的点的数量的最小值 = 两点之间点不相交（不在除了这两点以外的点相交）的路径数量的最大值。</li><li><strong>证明</strong>：最大流最小割定理。</li></ul><h3 id="点双中的路径性质" tabindex="-1">点双中的路径性质 <a class="header-anchor" href="#点双中的路径性质" aria-label="Permalink to &quot;点双中的路径性质&quot;">​</a></h3><ul><li>点双中任意两点 (x,y) 和任意一边 (e)，存在 (x\\rightarrow e\\rightarrow y) 的简单路径。</li><li>点双中任意三点 (x,y,z)，存在 (x\\rightarrow y\\rightarrow z) 的简单路径。</li></ul><h2 id="求边双-割边" tabindex="-1">求边双（割边） <a class="header-anchor" href="#求边双-割边" aria-label="Permalink to &quot;求边双（割边）&quot;">​</a></h2><ol><li><strong>low[x] 的本质</strong> 注意 (low[x]) 的本质是 dfs 树中 (x) 子树的非树边能覆盖到的最浅祖先。当然，树上差分也可以处理覆盖。</li><li><strong>割边的判定</strong> 根据 Menger 定理，被覆盖了的树边必然不是割边，而割边必然是树边，所以这样求是对的。</li><li><strong>边双的处理</strong> 边双在 dfs 树上是占据了一个连通块，所以可以通过栈来处理。每次判定当前已经到了一个边双（所在连通块）的最高点，就将当前边双 pop 出去。</li></ol><h2 id="求点双" tabindex="-1">求点双 <a class="header-anchor" href="#求点双" aria-label="Permalink to &quot;求点双&quot;">​</a></h2><p>原理类似边双。求割点注意根节点必须有两个儿子（不是叶节点）才是割点。</p><h2 id="tarjan-求强连通分量-有向图-dfs-树相关" tabindex="-1">tarjan 求强连通分量（有向图 dfs 树相关） <a class="header-anchor" href="#tarjan-求强连通分量-有向图-dfs-树相关" aria-label="Permalink to &quot;tarjan 求强连通分量（有向图 dfs 树相关）&quot;">​</a></h2><ol><li><strong>有向图 dfs 树的边类型</strong> 在分析强连通分量时，因为其定义，所以从任意一点开始用 dfs 考虑。有向图的 dfs 树中有四种边：树边，返祖边，前向边，横叉边。其中，前向边对于连通性没有影响，可以暂时不管。</li><li><strong>返祖边与横叉边的作用</strong><ul><li>返祖边能让边到的祖先和当前点的路径上的所有点都进入 SCC。</li><li>重点看横叉边，其有用当且仅当其能到当前点的祖先（通过若干横叉边，返祖边）。</li></ul></li><li><strong>SCC 的处理与 low[x] 的维护</strong><ul><li>SCC 在 dfs 树上仍然是占据了一个连通块，所以还是通过栈来处理，想办法在最高点做出判定。发现，核心还是在返祖边，而横叉边是传递作用。所以还是考虑维护当前节点 (x) 能到的最高祖先的 (dfn)，即 (low[x])。</li><li>首先直接对儿子的最高祖先取 (min)，然后考虑当前节点的返祖边直接取 (dfn) 作 (chkmi)，前向边不作更新。</li><li>而横叉边首先保证能到当前节点的祖先，可以发现如果能到某个祖先 (y)，那么 (y) 一定是该横叉边两端点的 (lca) 的祖先，所以这些点一定还保存在栈中，记录一下每个节点是否在栈中，在的话才要取其 (low) 作 (chkmi)。</li></ul></li><li><strong>最高点的判定</strong> 最高点的判定就是 (low[x] == dfn[x])，及时 pop。当然，我们发现横叉边也可以取 (dfn) 作判定，前向边也可以不特判，效果一样。</li><li><strong>模板与扩展</strong><ul><li>我们常写的模板是最简洁的版本，事实上可以有多种实现。</li><li>扩展：取产生每个 SCC 的顺序的反序就是拓扑序。</li><li><strong>证明</strong>：一棵 dfs 树肯定是对的，多棵之间连接也是有序的（否则就会变成一棵）。</li></ul></li></ol><h2 id="kosaraju-求强连通分量" tabindex="-1">kosaraju 求强连通分量 <a class="header-anchor" href="#kosaraju-求强连通分量" aria-label="Permalink to &quot;kosaraju 求强连通分量&quot;">​</a></h2><p><code>szzjz</code> 此处未详细展开相关内容。</p>',21),e=[t];function n(s,h,u,d,g,c){return i(),a("div",null,e)}const x=l(o,[["render",n]]);export{_ as __pageData,x as default};
